> 当在浏览器地址栏输入一个网址，回车就能访问到该网站，回车后到底发生了什么？

* 整体来说：这个过程是 浏览器 和 服务器 通信的过程，具体来说就是网络中两个进程之间的通信
* 前提1：怎么标志一个网络中的进程？让进程唯一，这样才能找得到
  * 利用传输层的 协议 + 端口 可以标志 在主机中的唯一进程
  * 利用网络层的 IP地址 可以标志 在网络中 的唯一主机
  * 结合上面两点，以（ip地址，协议，端口）就可以标志一个网络中的进程
* 前提2：进程之间直接通信么？肯定不是
  * 根据TCP/IP五层网络协议架构，数据分层传递
    * 应用层
    * 传输层
    * 网络层
    * 数据链路层
    * 物理层
  * 使用TCP/IP协议的应用程序中，为了把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用，在传输层和应用层之间建立一个抽象层，也就是Socket抽象层
  * 结合以上分析，进程是通过套接字接口向网络中发送报文和从网络中接受报文
* 连接准备：客户端的进程怎么知道要跟谁通信？
  * 我们只知道一个网址，也就是域名，并不知道其具体的IP地址，没法唯一标志服务器
  * 所以需要通过域名解析来获取服务器(也就是目的主机)的IP地址
    * 在浏览器DNS缓存、操作系统的DNS缓存中找对应信息
    * 没找打，浏览器就会发起一个DNS的系统调用，向本地配置的首选DNS服务器发起域名解析请求
* TCP三次握手:
  * 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
  * 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
  * 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
  * 作用：
    * 在客户端和服务端之间建立连接
    * 同步连接双方的序列号和确认号并交换 TCP窗口大小信息
    * 防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
* 建立TCP连接后发起http请求：
  * 在J2EE中的过程：
    * 浏览器发送 http请求到 Web容器
    * 如果首次访问某个目标， Web容器建立对应Servlet
    * Web容器创建 请求对象 和响应对象
    * 在Web容器中调用Servlet的service方法，service方法将数据写入响应对象
    * Web容器取出响应数据 返回给浏览器
  * HTTP协议：基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据
    * 请求与响应：客户端发送请求，服务器端响应数据
    * 无状态的：协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态。下一次客户端向同样的服务器发送请求时，需要重新建立连接。
    * 应用层：Http是属于应用层的协议，配合TCP/IP使用。
    * TCP/IP：Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。
    * 目的：HTTP主要解决如何包装数据的问题，是应用层的协议，让传输的数据有具体的意义
  * HTTP请求报文
    * 请求行：
      * 请求方法：GET、POST、DELETE、PUT 等
      * 请求地址：URL:统一资源定位符（<协议>：//<主机>：<端口>/<路径>）
      * 协议版本：常用的有HTTP/1.0和HTTP/1.1
    * 请求头部：
      * 为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔
        * Host、User-Agent等
      * 请求头部的最后会有一个空行，表示请求头部结束
    * 请求数据：
      * 可选；GET请求没有请求数据
  * HTTP响应报文
    * 状态行
      * 协议版本
      * 状态码
        * 1xx：指示信息--表示请求已接收，继续处理
        * 2xx：成功
        * 3xx：重定向--要完成请求必须进行更进一步的操作
        * 4xx：客户端错误--请求有语法错误或请求无法实现
        * 5xx：服务器端错误--服务器未能实现合法的请求
      * 状态码描述
    * 响应头部
      * Server、Content-Type等
      * 响应头部的最后会有一个空行，表示响应头部结束
    * 响应数据
* 浏览器解析HTML
  * 浏览器拿到index.html文件后，就开始解析其中的html代码，
  * 遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），
  * 这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，
  * 下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以显示的顺序并不一定是代码里面的顺序
  * 最后渲染页面显示
* TCP四次挥手
  * 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
  * 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
  * 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
  * 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。