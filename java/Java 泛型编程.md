## Java 泛型编程



### 1. 定义及用途

* 英文：Generic

* Java泛型方法和泛型类使程序员能够使用单个方法声明来分别指定一组相关方法，或者使用单个类声明来指定一组相关类型。 
* 泛型实现了**参数化类型**的概念，使代码可以适用于多种类型
  * 将类型由原来的具体的类型参数化，类似于方法中的变量参数，
  * 此时类型也定义成参数形式（可以称之为类型形参）
  * 然后在使用/调用时传入具体的类型（类型实参）
  * 泛型的类型参数只能是类类型，不能是简单类型

### 2. 相对同类产品优势

* 无比较对象

### 3. 核心知识点

#### 3.1. 泛型只作用于编译阶段

* 在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦

* 泛型信息不会进入到运行时阶段-成功编译过后的class文件中是不包含任何泛型信息的

* 泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型

---

#### 3.2. 自定义泛型

##### 3.2.1. 分类

* 泛型接口；泛型类；泛型方法

##### 3.2.2. 泛型接口

* 在**接口之后**给出用到的类型参数，如：<K, V>
* 当接口被实现时，类型参数才被指定；若没有指定具体的数据类型，那么默认为Object类型

##### 3.2.3. 泛型类

* **类名之后**给出用到的类型参数，如：<K, V>
* 类型参数部分可以有一个或多个类型参数，它们之间用逗号分隔
* 泛型类又称为 参数化类或参数化类型
* `Box<T>`:创建一个`Box`对象时就要传递该类型，如：`new Box<Integer>();`

##### 3.2.4. 泛型方法

* 在**返回类型前**加一对<>,并在其中给出用到的类型参数，如：<K, V>

* 类型参数可用于声明泛型方法返回类型
* ` <E> void`:表面用到的类型参数E,没有返回值
* static方法要使用泛型能力，必须使其成为泛型方法，不然无法访问泛型类的类型参数

##### 3.2.5. 类型参数命名约定

- E - 元素，主要由Java集合(Collections)框架使用。
- K - 键，主要用于表示映射中的键的参数类型。
- V - 值，主要用于表示映射中的值的参数类型。
- N - 数字，主要用于表示数字。
- T - 类型，主要用于表示第一类通用型参数。
- S - 类型，主要用于表示第二类通用类型参数。
- U - 类型，主要用于表示第三类通用类型参数。
- V - 类型，主要用于表示第四个通用类型参数。

##### 3.2.6. 类型推断

* `<>` − 尖括号运算符表示类型推断,编译器可确定参数的类型 > Java SE 7可用
* `Box2<Integer> b = new Box2<>();`:中的<>即类型推断，避免了写Integer类型
* 限制：类型推断只对赋值操作有效

##### 3.2.7. 泛型起作用的区域

* 若泛型类和泛型内中的泛型方法都用了E来做类型参数，则泛型方法中的E和泛型类中的E无关

* 泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的，**泛型方法始终以自己定义的类型参数为准**

---

#### 3.3. 有界类型

* 有界类型参数：
  * 限制允许传递给类型参数的实参类型
  * `<T extends Comparable<T>>T`:只允许实现了Comparable接口的T类型
* 类型参数的多重边界：
  * 即：类型参数 可以使用 多个边界
  * 若有类作为绑定传递，它应该在接口之前先传递-先类后接口
  * `<T extends Number & Comparable<T>>T`:只允许实现了Comparable接口并且继承自Number类的T类型的

---

#### 3.4. 类型通配符

* 通配符：为了指定泛型中的类型范围

* 无限定通配符：？
  *  代替具体的**类型实参**；
  * 在逻辑上可为其他**类型实参**的父类，其具体引用只能调用类型无关的方法
* 类型通配符上限
  * 使用extends：`<? extends Number>`
  * 表示接收的类型实参为Number及其所有子类
  * 对于实现了`<? extends T>`的集合类只能将它视为Producer向外提供(get)元素
* 类型通配符下限
  * 使用super:`<? super Integer>`
  * 表示接收的类型实参为Integer及其所有父类
  * 对于实现了`<? super T>`的集合类只能将它视为consume写入(add)元素
  * 非要读出来，可用Object接收
* PECS:Producer Extends，Consumer Super
* - 如果只从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends)
  - 如果只向集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super)
  - 如果对同一个集合既要存又要取，那么就不要使用任何通配符。-或者通过其他形式来实现

3.4 类型擦除

* 为Java泛型是1.5之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码
* 类型擦除规则：
* - 用通用类型的类型参数替换其绑定的有界类型参数。
  - 如果使用无界类型参数，则使用`Object`替换类型参数。
  - 插入类型转换以保护类型安全。
  - 生成桥接方法以在扩展通用类型中保持多态。
    - 一个子类在继承（或实现）一个父类（或接口）的泛型方法时，在子类中明确指定了泛型类型，那么在编译时编译器会自动生成**桥接方法**
    - 建立桥接方法，则在方法调用时可以传入任何类型，容易导致类型转换异常
    - 桥接方法帮忙兼容1.5之前的Java版本

---

#### 3.5. 类型擦除

* 类型擦除：编译器使用实际的类或桥接方法替换泛型参数的过程
* 擦除规则：
* - 用**通用类型的类型参数**替换其绑定的**有界类型参数**。
  - 如果使用**无界类型参数**，则使用**`Object`**替换类型参数。
  - 插入类型转换以保护类型安全。
  - 生成桥接方法以在扩展通用类型中保持多态。
  - 擦除只擦除到其第一个边界
* 类型擦除导致的问题：
  * 不允许创建泛型数组，创建则报错，可用ArrayList实现类似功能
  * 不允许直接利用类型参数创建实例，可利用反射创建实例，还可以采用Factory和Template两种设计模式解决不能创建实例问题
    * 反射，需要调用Class对象的newInstance()方法，该方法需要使用默认构造器
    * 使用工厂模式，在工厂管理类使用泛型类，具体类型各一个工厂，并设置响应创建实例方法
  * 不能显示 引用 运行时的类型：
    * 不允许对泛型代码直接使用`instanceof`关键字，但利用通配符重新设置bounds，则可以使用；引入类型标签 对擦除进行补偿-可以使用isInstance判断类型
    * 不能转型-`(T) new Object()`会产生warning
    * 不能是使用new表达式 - `new T()`
  * 类型参数不允许为静态(`static`)。由于静态变量在对象之间共享，因此编译器无法确定要使用的类型
  * 不允许重载，类型擦除后签名一致了
  * 异常受限：catch语句不能捕获泛型类型的异常，因为异常的确切类型在编译器&运行期都必须知道

### 4. 常见面试题

* Java中的泛型是什么 ? 使用泛型的好处是什么?
  * 使用单个方法声明来分别指定一组相关方法
  * 提供了编译期的类型安全，确保你只能把正确类型的对象放入 集合中，避免了在运行时出现ClassCastException
* Java的泛型是如何工作的 ? 什么是类型擦除 ?
  * 泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。
  * 例如 List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。
  * 无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型
* 限定通配符和非限定通配符？
  * 即类型通配符上限&下限和无限类型通配符的区别：
* List<? extends T>和List <? super T>之间有什么区别 ?
* 编写一段泛型程序来实现LRU缓存?
  * LRU: Least recently used-最近最少使用
  * 实现原理：
    *  新数据插入到链表头部；
    * 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
    * 当链表满的时候，将链表尾部的数据丢弃
  * LRU-K ：最近使用K次后，将数据索引从历史队列删除，将数据移到缓存队列中；没有达到K次，按规则淘汰
* 可以把List<String>传递给一个接受List<Object>参数的方法吗？
  * 不能
* 如何阻止Java中的类型未检查的警告?
  * 使用@SuppressWarnings(“unchecked”)注解来屏蔽。
* Java中List<Object>和原始类型List之间的区别? 
  * 编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查
  * 可以把任何带参数的类型传递给原始类型List，但却不能把List<String>传递给接受 List<Object>的方法
* Java中List<?>和List<Object>之间的区别是什么? 
  * List<?> 是一个未知类型的List，而List<Object> 其实是任意类型的List
  * 可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给 List<Object>

### 5. 综述

* 泛型内容繁复，编程中较少用到，各类源码中用得较多，如JDK的集合

### 6.参考资料

* 《Java编程思想》

* [Java总结篇系列：Java泛型](https://www.cnblogs.com/lwbqqyumidi/p/3837629.html)

* [Java泛型教程](https://www.yiibai.com/java_generics/)

* [泛型常见面试题](https://www.cnblogs.com/huajiezh/p/6411123.html)