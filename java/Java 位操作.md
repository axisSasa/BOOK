## 位操作

### 1. 定义及用途

* 位操作主要是针对数值操作

### 2. 相对同类产品优势

* 位操作比起一般的四则运算之类的快

### 3. 核心知识点

#### 3.1. 原码-反码-补码

* 计算机在进行数值运算的时候，是通过**补码**表示每个数值的

* 原码：
  * 把一个数字转换称二进制，就是原码；
  * 原码的最高位为符号位
  * `int a = 5; //原码  0000 0000 *** 0000 0101 `
  * `int b = -3;  //原码  1000 0000 *** 0000 0011`
* 反码：
  * 正数的反码就是原码
  * 负数的反码是，在原码的基础上符号位不变，其他位取反
  * 5 的反码：0000 0000 *** 0000 0101
  * -3 的反码：1111 1111*** 1111 1100
* 补码：
  * 正数的补码就是原码
  * 负数的补码是取其反码+1 = 也称-取反加一
  * 5 的补码：0000 0000 *** 0000 0101
  * -3 的补码: 1111 1111 *** 1111 1101

---

#### 3.2. 按位操作符

* &、|、~、^

##### 3.2.1. & 按位与操作符

* 从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值都是 1，则结果值相应的 bit 就是 1，否则为 0
* 1 1 得 1；其他得0

##### 3.2.2. |  按位或操作符

* 从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值只要 1 个为 1，则结果值相应的 bit 就是 1，否则为 0
* 有 1 得 1；其他得0

##### 3.2.3. ~  按位取反操作符

* 对操作数的每一位进行操作，1 变成 0，0 变成 1

##### 3.2.4. ^  按位异或操作符

* 两个操作数进行异或时，对于同一位上，如果数值相同则为 0，数值不同则为 1
* 不同得1；相同得0

##### 3.2.5. 针对布尔值得按位操作

* 效果和逻辑操作相同
* 但 按位操作不会短路

#### 3.3. 移位操作符

* << ; >> ; >>>
* **只**用于处理整数类型
* byte,short,char类型的数值在进行移位处理之前，会被转换成int类型，得到的结果也是int类型
* 对long类型的数值进行处理，得到的结果也是long类型
* 移位操作可与赋值符号一起使用，但因为byte,short,char的自动类型转换，得到意外结果

##### 3.3.1. << 左移操作符

* 左边操作数每位向左边移动，高位移出(舍弃)，低位的空位补零
* 5得补码：0000 0000 *** 0000 0101
* 执行 5 << 31,得1000 0000 ***  0000 0000
* 执行 5 << 1, 得0000 0000 *** 0000 1010

##### 3.2.2. >> 有符号右移操作符

* 左边操作数每位向右边移动，使用符号扩展，若符号为正，则高位插0，若符号为负，则高位插1
* -3的补码：1111 1111*** 1111 1101
* 5得补码：0000 0000 ***0000 0101
* -3 >> 1: 1111 1111*** 1111 1110
* 5 >> 1: 0000 0000 ***0000 0010

##### 3.2.3. >>> 无符号右移操作符

* 使用 零扩展，我也可以吧正负，高位插0
* -3的补码：1111 1111 ***1111 1101
* -3 >>> 1: 0111 1111 ***1111 1110
* 5 >>> 1: 0000 0000*** 0000 0010
* 若右操作数为负数： 所有的右边操作数为负数的情况都等同于取该操作数补码的后面5位于 0b11111逻辑与，其结果作为新的右操作数

#### 3.4. 位操作的骚操作

* 异或：
  * x^000..000 = x ;
  * x^111..111 = ~x; 
  * x^x = 0;
* 与：
  * x&000..000 = 0;
  * x&111..111 = x;
  * x&x = x;
* 或：
  * x|000..000 = x;
  * x|111..111 = 111..111;
  * x|x = x;
* 获取第r位
  * 我们将1开始左移r位，得到形如00010000..类似的串，然后执行**位与**操作
  * 结果为0，则,第r位为0，否则为1
  * `(num&(1<<r))!=0`
* 置位
  * 将1左移location位，接着用这个值和num进行“位或”操作，这样只会改变i位的数据
  * 将location位改为1
  * `num|(1<<location)`
* 清零
  * 与“置位”操作相反：
  * 将location位改为0
  * `num&(~1<<location)`

#### 3.5. 运算符优先级

| 优先级 | 运算符                                     | 结合性   |
| ------ | ------------------------------------------ | -------- |
| 1      | (),[],.                                    | 从左到右 |
| 2      | !,+(正号),-(负号),~,++,–                   | 从右到左 |
| 3      | +,/,%                                      | 从左到右 |
| 4      | +(加号),-(减号)                            | 从左到右 |
| 5      | <<,>>,>>>                                  | 从左到右 |
| 6      | <,<=,>,>=,instanceof                       | 从左到右 |
| 7      | ==,!=                                      | 从左到右 |
| 8      | &(按位与)                                  | 从左到右 |
| 9      | ^(按位异或)                                | 从左到右 |
| 10     | \|(按位或)                                 | 从左到右 |
| 11     | \|\|                                       | 从左到右 |
| 12     | &&                                         | 从左到右 |
| 13     | ?:                                         | 从右到左 |
| 14     | =,+=,-=,*=,/=,%=,&=,\|=,^=,~=,<<=,>>=,>>>= | 从右到左 |

### 4. 常见面试题

* 编写一个函数，确定需要改变几位，才能够将整数A转换成整数B
  * 计算出两个数之间有哪些位不同，很简单使用异或操作（^）
  * 遍历时，利用无符号右移操作每次向右移一位；计数时用最低位与1
* 编写程序，交换某个整数的奇数位和偶数位（即位0与位1交换，位2与位3交换，。。。），使用指令越少越好
  * 奇数位（偶数位）提出来统一移动一位，然后将二者的结构进行或运算即可
  * `(x&0xaaaaaaaa)>>>1)|((x&0x55555555)<<1)`
  * 解析：0xa = 10 = 0b1010; 0x5 = 5 = 0b0101
  * x&0xaaaaaaaa 得 x的偶数位，奇数位全为0，无符号右移一位：得偶数位 全部到 奇数位， 偶数位全为0
  * x&0x55555555 得 x的奇数位，偶数位全为0，左移一位：得奇数位全部到偶数位，奇数位全为0
  * 针对上述结果做按位或操作，结合奇数位和偶数位
* 要求设计实现一个功能: 当收到了一个新短信啥，如果手机短信容量还没"用完"（用完即已经存储256条），请分配给它一个可用的ID。由于手机很破，我要求你的程序尽量快，并少用内存.
  * 使用BitSet，存储，底层位long，每一位占一个bit，设置或取结果都是布尔值
* 有一个正整数，请找出与其二进制表示中1的个数相同、且大小最为接近的两个数
  * 获取较大值：
    * 找到不是拖尾的第一个0，该位置记为pos
    * 将该pos的0，置为1
    * 计数pos右边1的个数为count
    * 将pos右边全置为0
    * 将pos右边紧邻的(count-1)位，置为1
  * 获取较小值：
    * 找到不是拖尾的第一个1，该位置记为pos
    * 将该pos的1，置为0
    * 计数pos右边1的个数为count
    * 将pos右边全置为0
    * 将pos右边紧邻的(count+1)位，置为1

### 5. 综述

* 位操作少见，但运用得好有利于优化代码，特别是在节约存储空间上
* 位操作也极易出错，需注意int是4字节32位，以及所有数值都是补码表示这两点

### 6. 参考资料

* 《Java编程思想》
* [可能是最通俗易懂的 Java 位操作运算讲解](https://blog.csdn.net/briblue/article/details/70296326)
* [Java中关于无符号右移的问题 （~0L>>>-5）当右边为负数的情况](https://blog.csdn.net/IT_NEU_Lee/article/details/79538206)
* [位操作算法的总结（一）](https://blog.csdn.net/qq_16811963/article/details/52225504)
* [一道面试题与Java位操作 和 BitSet 库的使用](https://www.cnblogs.com/yellowb/p/3647442.html)
* [Java面试题链表、树和位操作](https://blog.csdn.net/Mikeoperfect/article/details/78305756)
* [总结一下java中的位操作,运算优先级](https://blog.csdn.net/sadjladjlas/article/details/51192106)