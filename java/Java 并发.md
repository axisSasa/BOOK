## Java 并发

### 1. 定义及用途

 * Java 并发是说同一个程序当中可以有多个线程**”同时“**运行【单核多线程串行；多核可并行】
 * 用于执行多任务的情况；
 * 并发编程还能充分利用**多核**CPU的计算能力，提升性能

### 2. 相对同类产品优势

 * 多线程与单线程相比：
    * 提高资源利用率【减少CPU空闲时间】
    * 在特定情况下【线程间很少共享数据】，编码简洁、容易
    * 程序响应更快

### 3. 核心知识点

#### 3.1. 线程

* 线程的生命周期：
  * new: 建立线程后，直到程序启动线程为止，它保持在这种新建状态【调用start()方法前】
  * runnable：线程对象调用start后，线程将进入就绪状态；JVM会为线程创建函数调度栈和计数器
  * running：就绪状态的线程获取了CPU执行片的之后，就进入运行状态
  * 运行时可能被以下等情况阻塞-进入阻塞/等待状态-blocked/waiting：
    * CPU执行片已经用完
    * 线程调用了`sleep()`
    * 线程调用了阻塞IO方法
    * 线程在等待某个通知
    * 线程试图获取被其他线程持有的同步监视器【一个普通的java对象】
  * dead：可执行线程在完成任务或以其他方式终止时进入终止状态
* 如何创建&启用Java线程：
  - 创建Thread类的**子类**,并**重写**run()方法；实例化Thread类的子类并**调用**start()方法
  - 创建一个Thread类的匿名子类的实例，并调用start()方法
  - 实现了java.lang.Runnable接口的**类**,并**实现**run()方法；在Thread类的构造函数中**传入**实现了Runnable接口的类的实例，并**调用**start()方法
  - 在Thread类的构造函数中传入实现了Runnable接口的匿名类的实例，并调用start()方法
* 线程优先级：
  * 线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行
* 主线程main是用户线程-其终止条件：
  * 调用了exit()方法，并且exit()有权限被正常执行
  * 当只有守护线程运行时，JVM会自动退出

---

#### 3.2. 并发专有名词解析

##### 3.2.1 竞态条件 & 临界区

* 竟态条件：如果两个线程竞争同一个**资源**【内存区，系统，文件】，此时如果对资源的**访问顺序敏感**【不同的顺序产生不同的结果,主要是写操作】，就称存在**竟态条件**
* 临界区：导致竟态条件发生的代码的区域称为**临界区**
* 避免竟态条件：对临界区代码使用同步机制

##### 3.2.2 线程安全&共享资源

- 允许被多个线程同时执行的代码称**作线程安全的代码**；局部变量存在在Java虚拟机栈中是私有的，线程安全，但局部变量中的引用类型指向的对象在Java堆中，如果被其他线程访问到则是线程不安全的
- 线程控制逃逸规则：如果**一个资源**的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。
- "即使对象本身线程安全，但如果该对象中包含其他**资源**（文件，数据库连接），整个应用也许就不再是线程安全的了"

##### 3.2.3. 死锁&避免死锁

- 死锁：多个线程同时但以不同的顺序请求同一组锁的时候，形成死锁

- 避免死锁：

  - 加锁顺序：所有线程都按照一定的顺序加锁

  - 限制加锁时间：线程在规定时间内未获得需要的锁，则放弃尝试获取锁且放弃已获得的锁，之后再重试--这种超时和重试机制，在线程过多的情况下，可能出现连续死锁的情况

  - 死锁检测： 通过记录线程和线程持有的锁及请求的锁，检测是否有死锁的情况发生，若发生则可利用释放所有锁，再重试，或者释放特定的锁，再优先级高的线程先运行

##### 3.2.4. 饥饿和公平

- 饥饿：一个线程得不到CPU时间来执行的状态
- 公平：解决饥饿的方案
- 提高等待线程的公平性：使用锁方式代替同步块
- 公平锁实现：加锁方法只是将线程放入队列，解锁后，只允许队列的第一个线程获得公平锁实例；各个线程只会唤醒各自的wait()方法，因为每个线程都有自己的排队对象，等待唤醒都在各自对象上进行，互无影响，只是靠公平锁来统一调用

##### 3.2.5. 嵌套管程锁死

- 与死锁很像：都是线程最后被一直阻塞着互相等待
- 死锁中，二个线程都在等待对方释放锁；嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。

##### 3.2.6. 重入锁死

- 如果一个线程持有某个管程对象上的锁，那么它就有权访问所有在该管程对象上同步的块。这就叫可重入
- 当一个线程重新获取不可重入的同步器时，就可能发生重入锁死
- 避免重入锁死：编写代码时避免再次获取已经持有的锁；使用可重入锁

##### 3.2.7. 阻塞队列

- 阻塞队列：从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞
- 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来
- 实现类似于带上限的Semaphore的实现
- 可解决生产者、消费者速率不一致的问题

##### 3.2.8. CAS

* 一个期望值和一个变量的当前值进行**比较**，如果当前变量的值与我们期望的值相等，就使用一个新值**替换**当前变量的值

##### 3.2.9. 原子性

* 一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
* Java中的原子性：
  * 对基本数据类型的变量的读取【x】和赋值【x = 1】操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行
  * synchronized或Lock 也能保证原子性

##### 3.2.10. 有序性

* 程序执行的顺序按照代码的先后顺序执行
* 指令重排序（Instruction Reorder）：不保证程序有序性，但是它会保证程序最终执行结果和代码按顺序执行的结果是一致的-进行重排序时是会考虑指令之间的数据依赖性-重排序对单个线程无影响
* Java中的有序性：
  * 通过volatile关键字来保证一定的“有序性” -volatile关键字禁止指令重排序
    * 程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行；且前面操作的结果已经对后面的操作**可见**；在其后面的操作肯定还没有进行
    * 指令重排序时，在volatile变量前的始终在其前；在volatile变量后的始终在其后
  * synchronized和Lock也能保证有序性
  * 先天的“有序性”/happens-before 原则/先行发生原则：
    * 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
    * 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作
    * volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
    * 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
    * 线程启动规则；线程中断规则；线程终结规则；对象终结规则

##### 3.2.11. 可见性

* 当多个线程访问同一个变量时，一个线程**修改**了这个变量的值，其他线程能够**立即**看得到修改的值
* Java中的可见性: 
  * 一个共享变量被volatile修饰时，它会保证**修改**的值会**立即被更新到主存**，当有其他线程需要读取时，它会去内存中读取新值
  * synchronized和Lock也能够保证可见性

##### 3.2.12. 共享变量

* 在多个线程之间能够被共享的变量被称为共享变量
* 共享变量包括所有的实例变量，静态变量和数组元素,都被存放在堆内存中
* Volatile只作用于共享变量

##### 3.2.13. 内存屏障 

* 是一组处理器指令，用于实现对内存操作的顺序限制

##### 3.2.14. 原子操作 

* 不可中断的一个或一系列操作

##### 3.2.15. ABA问题

* 一个变量被从A修改到了B，然后又被修改回A的一种情景。其他线程对于这种情况却一无所知
* 解决方案：在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A



---

#### 3.3. 同步关键字synchronzied-隐式锁

* synchronized产生的内置锁：每个java对象都可以用做一个实现同步的锁，这些锁成为**内置锁**。线程进入同步代码块或方法的时候 会自动获得该锁，在退出同步代码块或方法时会释放该锁。 【获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法】

* synchronzied使用地方：
  * 可用于实例方法及实例方法内
  * 可用于类方法及类方法内

* synchronzied使用方法：
  * 直接用于方法，则在方法定义前加 synchronzied
  * 作用于方法内部，则使用同步块

* synchronzied锁对象确认：

  * 当synchronized作用于普通方法是，锁对象是this；**”对象锁/实例锁“**

  * 当synchronized作用于静态方法是，锁对象是当前类的Class对象；**”类锁“**

  * 当synchronized作用于代码块时，锁对象是synchronized(obj)中的这个obj

---

#### 3.4. 线程通信

- 在共享对象的变量里设置信号值
- 忙等待(Busy Wait) 持续访问特定信号值，直至信号值改变
- wait(),notify()和notifyAll() 实现等待-唤醒机制：一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块才可以，因为：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用
- 丢失的信号（Missed Signals）没有等待的线程，但调用了notify；可增加通知信号避免丢失信号
- 假唤醒 线程有可能在没有调用过notify()和notifyAll()的情况下醒来
- 在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象作为管程

---

#### 3.5. TheadLocal-提供线程内的局部变量

- 各线程私有，初始默认值为null
- 继承TheadLocal的子类复写initialValue()方法可构造统一初始值
- ThreadLocalMap是使用ThreadLocal的弱引用作为Key的，gc时容易内存泄露：在调用get,set时将key为null的这些Entry都删除；手动调用ThreadLocal的remove函数；将ThreadLocal对象定义为static的，保持强引用

---

#### 3.6. 显示锁Lock-ReentrantLock

* 用作线程同步机制，类似于同步块
* 锁和同步块的区别：
  * 同步块不提供对等待线程进行访问的序列的任何保证,Lock提供
  * 同步块没有超时选项，Lock可超时释放
  * 同步块不能中断，Lock进行等待的情况下，可以响应中断
  * 同步块不能知道有没有获取到锁，Lock知道
  * Lock可以提高多个线程进行读操作的效率
  * 更公平
  * 在不同的范围，以不同的顺序获取和释放锁
* Condition：
  * 提供了类似Object监视器的方法,与Lock配合来实现等待/通知模式
  * 所以`Condition`对象必须绑定到`Lock`;使用Lock`newCondition()`方法获取对象
  * `Condition`内部维护了等待队列的头结点和尾节点,等待signal信号

---

#### 3.7. volatile

* 中文：易变的，不稳定的
* 可用于
  * 在并发中保持变量的可见性	
  * 维持代码一定程度上的有序性
* 使用场景：
  * 状态标记量
  * 双重检查锁
* 优势：相对synchronizied,volatile不会引起线程上下文的切换和调度

#### 3.8. 原子变量

* 提供原子操作，提供保持内存一致性的修改方法【CAS】:arrow_right: 简化同步处理

* AtomicLong;AtomicBoolean;AtomicInteger;AtomicReference;AtomicIntegerArray;AtomicLongArray
* 适用场景：多线程计数器



---



#### 3.9. 线程池

* 线程池相对野线程优点：
  * 重用存在的线程，减少对象创建、消亡的开销，性能佳  
  * 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞  
  * 提供定时执行、定期执行、单线程、并发数控制等功能
* Executors中的线程池：
  * 提供了一系列静态工厂方法用于创建各种线程池
  * newFixedThreadPool：创建可重用固定数目线程的线程池，以无界队列来维持线程
  * newCachedThreadPool：可缓存的线程池，可增长，可回收
  * newSingleThreadExecutor：只有单个线程
  * newScheduledThreadPool：支持定时及周期性的任务执行的线程池

---

#### 3.10. Executor框架

- 中文：执行者; 实行者
- 内部使用了线程池机制；该框架用来控制线程的启动、执行和关闭
- Executor：支持启动新任务的一个接口
  - execute(Runnable)：在将来的某个时间执行Runnable任务
- ExecutorService：
  - 继承自Executor接口
  - submit(Callable): 
    - 执行Callable任务，
    - 可以`Future`对象的方式返回由线程完成的计算结果
    - Future可检查Callable状态，方便在执行完成后获取计算结果
  - 能管理生命周期
    - 运行：创建后便进入运行状态
    - 关闭：调用了shutdown（）方法时，便进入关闭，不再接受新的任务，但它还在执行已经提交了的任务
    - 终止：当调用shutdown()后，在调用之前已提交的方法都执行完成后，进入终止状态

---

#### 3.11. fork-join框架

* 用于**并行**执行任务的框架
* 框架思路：把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果
* 框架实现：
  * 把分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。
  * 子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据
* 创建ForkJoin任务：
  * RecursiveAction：用于没有返回结果的任务
  * RecursiveTask:用于有返回结果的任务
  * 且需覆盖compute()方法
* 执行ForkJoin任务：ForkJoinPool
  * fork-join池是是一个work-stealing工作窃取线程池。每个工作线程维护本地任务dequeue
  * 与线程池比：Forkjoin池里的线程不是在是等待新任务，而是主动分裂的现有任务到更小的，并帮助完成其他线程的大任务(切分以后)

---

#### 3.12. 并发集合

 * 暂无

---

#### 3.0. 几种锁介绍

##### 3.0.1. 可重入锁

* 如果锁具备可重入性，则称作为可重入锁
* 可重入性：如果一个线程持有某个对象上的锁，那么它就有权访问所有在该对象上同步的块，这就叫可重入
* synchronized和Lock都具备可重入性

##### 3.0.2. 可中断锁

* 可以响应中断的锁
* synchronized就不是可中断锁，而Lock是可中断锁

##### 3.0.3. 公平锁

* 尽量以请求锁的顺序来获取锁
* synchronized就是非公平锁；ReentrantLock和ReentrantReadWriteLock默认是非公平锁，但可设置锁的公平性

##### 3.0.4. 读写锁

- **读锁** - 如果没有线程锁定`ReadWriteLock`进行写入，则**多线程**可以访问读锁。
- **写锁** - 如果没有线程正在读或写，那么**一个线程**可以访问写锁
- 申请锁：
  - 一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁
  - 一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁

---

### 4. 常见面试题

#### 4.1. 多线程

* 进程和线程有什么不同？
  * 一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。
  * 而线程是在进程中执行的一个任务。
  * Java运行环境是一个包含了不同的类和程序的单一进程。
  * 线程可以被称为轻量级进程。
  * 线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。
* 多线程编程好处？
  * 多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。
  * 多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好

* 什么是Daemon线程？它有什么意义？用户线程和守护线程的区别？
  * 在程序运行的时候在后台提供一种通用服务的线程，比如[垃圾回收](https://www.baidu.com/s?wd=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分
  * 用户线程结束，虚拟机会退出
* 什么是线程调度器&时间分片？
  * 线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间
  * 时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程
  *  线程调度并不受到Java虚拟机控制，最好手动控制线程调度，而不依赖于给线程设定的优先级
* 什么是上下文切换？
  * CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，**从任务保存到再加载的过程就是一次上下文切换** 
* thread类中的yield方法有什么作用？
  * 当前线程愿意让出CPU资源给其他线程/Thread.yield()在哪个线程中被调用就 表示哪个线程愿意放弃处理器资源
* 可以直接调用thread类的run方法么？
  * 可以，但run方法就不会在run方法所属的对象建立的线程执行，而是在方法调用所在的线程执行
* 如何确保mian()方法所在线程是最后结束的线程？
  * 我们可以使用`Thread`类的`join()`方法来确保所有程序创建的线程在`main()`方法退出前结束.
  * 线程A调用线程B的join方法，那么线程A的运行会被暂停，直到线程B运行结束
  * 利用CountDownLatch计数线程
* 为什么线程通信方法被定义在Object里？
  * Java中每个对象都有一个锁
  * 在Java线程中并没有可供任何对象使用的锁和同步器. 
  * 这些方法是`Object`类的一部分, 这样Java的每一个类都有用于线程间通信的基本方法
* 为什么Thread的sleep()和yield()方法是静态的？
  * `Thread`类的` sleep()`和 `yield()`方法将在当前正在执行的线程上运行, 所以在其他处于等待状态的线程上调用这些方法是没有意义的, 这就是为什么这些方法是静态的. 
  * 他们可以在当前正在执行的线程中工作, 避免程序员错误的认为可以在其他非运行线程调用这些方法.
* sleep()和 wait()有什么区别？
  * sleep就是正在执行的线程主动让出cpu一段时间去执行其他线程，之后继续执行
  * 当前线程进入了同步锁，sleep方法并不会释放锁
  * wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁

#### 4.2. 锁

* 乐观锁和悲观锁的理解及如何实现，有哪些地方用到了？
  * 理解：
    * 悲观锁总是假设最坏的情况（认定要访问的数据肯定被别人修改，所以每次访问必上锁）
    * 乐观锁总是假设最好的情况（认定别人一定不会随便修改数据，所以访问不上锁）
  * 运用：
    * synchronized关键字的实现是悲观锁
    * atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的
  * 实现：
    * synchronize或Lock
    * 乐观锁：可以使用volatile+CAS原语实现

#### 4.3. 并发框架

* 如何让一段程序并发的执行，并最终汇总结果？
  * 使用CyclicBarrier 在多个关口处将多个线程执行结果汇总 -await()屏障拦截
  * CountDownLatch 在各线程执行完毕后向总线程汇报结果
  * 两种方式区别：
    * CountDownLatch是减计数方式，而CyclicBarrier是加计数方式
    * CountDownLatch计数为0无法重置-不可复用，而CyclicBarrier计数达到初始值，则可以重置-可复用
* 如何合理的配置java线程池？如CPU密集型的任务，基本线程池应该配置多大？IO密集型的任务，基本线程池应该配置多大？用有界队列好还是无界队列好？任务非常多的时候，使用什么阻塞队列能获取最好的吞吐量？
  * 配置线程池时CPU密集型任务可以少配置线程数，大概和机器的cpu核数相当，可以使得每个线程都在执行任务
  * IO密集型时，大部分线程都阻塞，故需要多配置线程数，2\*cpu核数 
  * 有界队列和无界队列的配置需区分业务场景，一般情况下配置有界队列，在一些可能会有爆发性增长的情况下使用无界队列
  * 任务非常多时，使用非阻塞队列使用CAS操作替代锁可以获得好的吞吐量

#### 4.4. 线程安全

* 什么叫线程安全？servlet是线程安全吗?   Spring mvc 线程不安全的原因？
  * 线程安全：多线程访问同一代码，不会产生不确定的结果
  * Servlet是单例多线程，不是线程安全的
  * Spring mvc 中如果controller对象是单例的，那么如在其中中定义了类变量，这个类变量是被所有请求共享，不安全
  * 解决Spring mvc线程不安全：
    * 在类上添加注解@Scope("prototype")，这样每次请求调用的类都是重新生成的（每次生成会影响效率）
    * 使用ThreadLocal 来保存类变量，将类变量保存在线程的变量域中，让不同的请求隔离开来
* 同步有几种实现方法？
* volatile有什么用？能否用一句话说明下volatile的应用场景？   

#### 4.5. 线程池

* 线程池中submit() 和 execute()方法有什么区别？
  * execute只能提交一个Runnable的对象，且该方法的返回值是void
  * submit有3种提交方式：
    * submit(Callable)【实现了Callable接口的对象】，返回一个代表这线程的执行结果Future对象；主线程调用Future的get方法的时候会获取到从线程中返回的结果数据
    * submit(Runable)，主线程调用Future的get方法的时候，任务执行成功返回null
    * submit(Runable, T result)，调用Future的get方法会返回result对象
    * 若线程执行有异常，则get()获取到的是异常信息

### 5. 综述

* 线程涉及知识甚广，东西甚多；但还是有迹可循
  * 单核多线程，提高对CPU的利用，避免堵塞
  * 多核多线程，提供并行计算的能力
  * 多线程编程涉及对共享资源的调用-同步-锁-原子变量-volatile-死锁-饥饿
  * 线程之间的通信-等待/唤醒机制-Condition
  * 线程的综合利用-线程池-Executor等

### 6. 参考资料

* [线程优先级和守护线程](https://www.cnblogs.com/xiaoxi/p/7133002.html) 
* [Java 浅析 Thread.join()](https://www.cnblogs.com/huangzejun/p/7908898.html)
* [深入理解java内置锁(synchronized)和显式锁(ReentrantLock)](https://www.jb51.net/article/129060.htm)
* [java synchronized对象锁与类锁的区别、同步代码块与同步方法的区别](https://blog.csdn.net/u010002184/article/details/72566874?locationNum=11&fps=1)
* [Java并发编程：Lock](https://www.cnblogs.com/dolphin0520/p/3923167.html)
* [怎么理解Condition](http://www.importnew.com/9281.html)
* [Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)
* [线程池的submit和execute的区别](https://blog.csdn.net/guhong5153/article/details/71247266)