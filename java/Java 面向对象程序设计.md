## 面向对象程序设计

### 1. 定义及用途

* 基调：Java中一切皆对象
* 根据解决问题需要创建合理且合适的对象，在对象的角度上，思考为了解决问题对象应该具备的功能，再通过利用这些对象编码解决实际问题，这就是**我理解的面向对象程序设计**
* 通过面向对象，能更好的理解待解决问题中的对象关系
* 面向对象的基本特征：封装-继承-多态
* 面向对象的五大设计原则：
  * 单一职责原则SRP(Single Responsibility Principle)
  * 开放封闭原则OCP(Open－Close Principle) 
  * 替换原则(the Liskov Substitution Principle LSP) 
  * 依赖倒置原则(the Dependency Inversion Principle DIP)
  * 接口分离原则(the Interface Segregation Principle ISP) 

### 2. 相对同类产品优势

* 相对面向过程编程：代码复用性更强，代码分成不同的类结构也更明确
* 面向过程的编程思想：把数据和过程独立考虑，直接站在计算机的角度去抽象问题&解决问题
* 面向对象的编程思想：把数据和行为都看作对象的一部分，站在现实世界的角度去抽象和解决问题

### 3. 核心知识点

#### 3.1. 类

##### 3.1.1. 类的定义

* 利用class关键字创建类
* 类名首字母大写，整体采用大驼峰风格
* 可用public修饰类，且一个文件得public修饰类只有一个
* 且文件名必须和public修饰得类名一致
* 且该类必须包含一个main()函数，不然无法直接执行该类
* 类中可以定义：字段/属性；成员方法；构造器；类变量/静态变量；类方法/静态方法

##### 3.1.2. 类的初始化

* import：要使用其他包中的类，需要import导入；但java.lang包会被自己导入每个Java文件中，可直接使用，同一个包下面的类【修饰符为public或默认修饰符】，也可以直接使用
* 类初始化需用构造器
  * 构造器名必须与类名相同
  * 构造器本身无返回值
  * 使用方法重载可以拥有多个构造器
    * Java中方法重载无法根据返回值区分，首先构造器本身无返回值
    * 其次方法调用的时候不一定需要返回值，所以编译器无法判定具体调用那个方法
  * 代码中不给构造器，编译器会替类自动生成一个无参构造器，也称默认构造器；一旦代码中定义任何构造器，编译器便不会帮忙生成无参构造器
  * 可以在构造器中调用其他构造器
    * 可以通过this()这种方式调用其他构造器，但此时this()必须置于构造器起始处，且只能调用一次
  * 继承时，构造器中若无显示调用super()，编译器会自动添加该方法
  * 编译器禁止从其他非构造器方法调用构造器
* 初始化-解析阶段，遇到某字段时某个对象的引用，还需初始化该引用
* 对象分配到的实例的内存会被初始化为零值，所以即使不调用构造器对字段赋值，字段也有默认值
* 初始化顺序：
  * 创建类的第一个对象 或者访问static方法或域时，开始加载类代码
  * 首先找出类的编译代码 XXX.class,然后对它进行加载
  * 若编译器发现其有基类，继续加载器基类，依此类推，直到根基类
  * 根基类的 static 初始化
  * 导出类的 static 初始化，依次类推，所有类得到static 初始化---至此，类加载完毕
  * 对象中所有的属性/字段设为零值
  * 从子类构造器中调用基类的构造器
  * 子类实例变量按次序初始化
  * 执行子类构造器剩下部分

#### 3.2. 访问权限控制

* 又称：具体实现的隐藏，将具体实现隐藏又可称为封装

##### 3.3.1. 包

* 包应全部小写字母命名

* 包内 包含 一组类，可以说那一组内都在同一包下
* 单一的Java文件默认位于 未命名包，也称默认包中
* 多个包中有类名相同的情况
  * 使用全限定名

---

##### 3.2.2. 包访问权限

* 没有任何关键字
* 包内的其他内都能访问
* 包外的类来说，访问权限如同private

##### 3.2.3. public

* 大家都可以访问

##### 3.2.4. private

* 只有包含该成员的类可以访问，其他任何类都不能访问
* 在单例模式的使用过程中，为了保证只有一个实例，不让代码产生第二个实例，便把构造函数设置为private的，避免外部直接调用new产生新实例，只能在静态方法中返回一个创建或返回一个实例
* 类不能是private的

##### 3.2.5. protected

* 与继承相关
  * 继承类来自其他包，只能访问public
  * 继承类来自本包，拥有包访问权限
* 若父类的成员用protected修饰
  * 被修饰的成员就能被父类的派生类访问
  * 包内其他类也能访问protected修饰的成员【具有包访问权限】
* 类不能是protected的

---

#### 3.3. 类的复用

* 组合复用现有类的功能；
* 继承复用现有类的接口；
* 代理复用并扩展现有类的功能

##### 3.3.1. 组合-has-a

* 在新类中产生现有类的对象-组合
* 组合进来的字段实例化：
  * 在定义对象的地方实例化
  * 在构造器中实例化
  * 在使用前实例化
  * 使用实例初始化【{}这部分代码会在构造函数执行前执行】

---

##### 3.3.2. 继承-is-a

* 按照现有类的类型来创建新类-继承
* 当创建一个类时，总是在继承
  * 从其他类继承
  * 从Object隐式继承
* Java在子类中使用super关键字表示超类
* 当创建一个导出类的对象时，该对象还包含了一个基类的子对象
  * 所以需要初始化基类
  * Java会自动在导出类的构造器中插入对基类构造器的调用
* 子类可以重写父类方法
  * 返回值一致
  * 方法名一致
  * 参数类型及顺序一致
  * 可以更改访问权限：
    * 更改的访问权限必须比超类更开放
    * 若父类一个方法是protected修饰，则重写方法只能是protected修饰或public修饰；private和默认包访问权限 不及 protected，不能使用
* 向上转型：
  * 新类是现有类的一种类型
  * 类继承图，基类在上，导出类在其下
  * 所以将导出类转型成基类，是向上移动，称为向上转型
  * 转型后调用 被子类重写覆盖过的方法
    * 注意 final修饰的方法，即使子类有同名同签名方法也不算覆盖
    * private修饰的同理

---

##### 3.3.3. 代理

* 静态代理
  * 将一个成员对象置于要构造的类中【组合也这样】
  * 在新类中一一暴露该成员对象的所有方法

---

#### 3.4. final

* 指明Java中一旦定义无法被改变的事务
* 运用地方：
  * 数据
  * 方法
  * 类
  * 参数
* final数据
  * 作为编译时常量：此常量必为基本数据类型，final修饰，定义时必初始化
  * final作用于引用类型时，引用地址不变，地址指向对象可变--该情况数组也适用
  * static强调“只有一份”，表示属于类
    * final 修饰的变量再定义为static，则装载时被初始化【类加载的准备阶段】
    * 非static的final，则在每次创建新对象时初始化
* 空白final
  * 指：声明为final，但未给定初始值
  * final使用前必须初始化
    * 要么在域的定义处初始化-非空白final
    * 要么在每个构造器中用表达式对final进行赋值-空白final
* final 方法
  * final修饰的方法 不会被子类 覆盖 - 方法锁定
    * 覆盖只能覆盖超类的接口部分方法【private final 修饰的方法不是接口的一部分】
  * 类中所有的private方法隐式的指定为 final
* final 类
  * 类定义为final时，禁止被继承
  * final 类的域，不一定是final
  * final 类的方法都隐式指定为final

---

#### 3.5. 多态

* 主要目的
  * 分离 做什么 和怎么做； 也就是 接口 和 实现 分离
* 多态：
  * 也称：动态绑定；后期绑定；运行时绑定
* 什么是绑定？
  * 关联 方法调用 和 方法主体 称为 绑定
* 什么是后期绑定？
  * 运行时，根据对象的类型 进行绑定
  * 除了static final private修饰的方法外，其他方法都属于后期绑定
* 协变返回类型
  * 在**导出类中的 被覆盖的方法**  可以返回 **基类方法的** **返回类型的** **某种导出类型**

---

#### 3.6. 接口&抽象类

* 接口：
  * 使用interface声明一个接口
  * 接口包含的域是隐式 static 和final 的
    * 但接口中定义的域 不能是 空白final
  * 接口中的方法都是默认 public 的；要实现一个接口方法时，实现方法也必须被定义为public的
  * 接口可以嵌套在其他类或者接口中
  * 不能直接创建接口的对象
  * 接口支持多继承
    * 一个接口可以同时extends多个接口
    * 一个接口不能implements任何接口
  * 接口中的方法：
    * 普通类实现一个接口，需要重写接口中的所有方法
    * 抽象类实现接口，可以完全覆盖/重写 接口中的方法，也可只重写接口中的某几个方法
      * 这种情况下，子类再继承抽象类时，子类重写的方法即为抽象类中未重写接口中的方法
    * 总的来说，接口中的所有方法都会得到重写
* 抽象类：
  * 包含抽象方法的类；也可以不必包含任何抽象方法；类前abstract修饰
  * 抽象方法：abstract修饰，且只有声明没有方法体的 方法
  * 只要一个类包含一个或多个抽象方法，则该类必须被声明为抽象类
  * 一个普通类只能继承一个抽象类
  * 一个普通类/非抽象类继承一个抽象类，就必须实现抽象类中的所有抽象方法，不然该类就不是普通类而是抽象类
  * 一个抽象类继承一个抽象类，不用重写抽象方法
  * 不能直接创建抽象类对象
* Java 中的多重继承
  * 多重继承：表示 x 是一个 a, 是一个b，是一个c。。。
  * Java 只允许 继承一个类，但允许实现多个接口
  * 导出类对象 都可以向上转型到 继承的超类类型 和实现的接口类型
  * 通过内部类，可以让一个外部类获得多个类的能力--简洁实现了多重继承

---

#### 3.7. 内部类

* 内部类：将一个类的定义放在另一个类的 内部
* 在外部内的非静态方法之外，创建内部类的对象，都必须使用 “外部类名.内部类名” 的方式指定类型
* 内部类的对象
  *  能访问 外部类对象的 所有成员
  * 内部类 拥有 外部类 的 所有元素的 访问权
  * 因为：内部类对象 有一个指向外部类对象的引用
* 在内部类 生成外部类对象的引用：
  * 外部类名.this
* 创建某个内部类对象：
  * 非嵌套类/非静态内部类：
    * 外部类对象.new 内部类名();
    * 拥有外部类对象之前，不可能创建内部类对象，因为内部类对象需要连接到创建它的外部类对象上
  * 嵌套类/静态内部类：
    * new 外部类名.内部类名();
    * 这个内部类对象没有指向外部类对象了，不能从嵌套类的对象访问非静态的外部类对象
    * 嵌套类 可以作为 接口的 一部分
      * 接口中任何类都是自动 public static的
  * 注意点：
    * 非静态内部类中不允许定义static成员 
    * 外部类的静态成员不可以直接使用非静态内部类 
    * 静态内部类，不能访问外部类的实例成员，只能访问外部类的类成员
* 内部类标识符：
  * 每个类都会产生一个.class文件，内部类也不例外
  * 内部类.class文件命名规则：外部类的名字$内部类的名字
* 匿名内部类：
  * 可以扩展一个类 或者 实现一个接口【不能同时继承&实现】
  * 匿名内部类创建格式：`基类 obj = new 基类() {};`
  * 没有名称，所以它不能有构造函数 
    * 使用实例初始化 来达到 类似构造器的效果---给字段赋值等
  * 若匿名内部类要使用在外部定义的对象，那么传入对象必须声明为final的；只传递进内部类但不使用，可不声明为final
  * 匿名内部类使用含参构造器，只需在new时传入参数即可
* 局部内部类：
  * 可在方法内定义局部内部类，也可以在静态初始化器，非静态初始化器和构造器中定义
  * 其范围限于其封闭块，因此其声明不能使用任何访问修饰符

### 4. 常见面试题

* 

### 5. 综述

* 面向对象是Java的基础，内容多且繁复，但有理可循，通过理解基础的知识，大多数细枝末节的知识点都能推断一二

### 6. 参考资料

* 《Java编程思想》

* [抽象类实现接口](https://www.cnblogs.com/IanI/p/4549851.html)
