## 运行期优化

### 1. 定义及用途

* 热点代码：运行频繁的方法或代码块
  * 被多次调用的方法
  * 被多次执行的循环体
* 虚拟机通过JIT编译器把热点代码编译成本地平台相关的机器码，并进行优化，以提高执行效率

### 2. 相对同类产品优势

* 

### 3. 核心知识点

#### 3.1. HostSpot的JIT

##### 3.1.1. 解释器与编译器

* 解释器优势：
  * 省去编译时间立即执行，利于程序迅速启动执行
  * 内存受限时，可节约内存
  * 作为编译器激进优化失败的逃生门
* 编译器优势：
  * 程序启动后，把代码编译成本地代码，获得更好的执行效率
  * 内存不受限时，可提升效率
  * HotSpot的编译器
    * C1,Client Compiler
    * C2,Server Compiler
* 虚拟机的运行模式：
  * 混合模式：解释器&编译器一起工作，搭配使用
  * 解释模式：-Xint参数限制在解释模式下运行，全部代码使用解释方式执行
  * 编译模式：-Xcomp参数限制在编译模式下运行，优先使用编译方式执行，实在不行，解释器再上
* 分层编译：
  * 根据编译器编译的规模、耗时，划分不同的编译层次；使得程序启动响应速度&运行效率达到平衡
  * 第0层：程序解释执行，解释器不开性能监控可触发第1层
  * 第1层：C1编译，字节码编译为本地代码，进行可靠优化
  * 第2层：C2编译，字节码编译为本地代码，启用编译耗时较长的优化，激进优化

---

##### 3.1.2. 编译对象&触发条件

* 栈上替换
  * On Stack Replacement,简称OSR编译
  * 编译发生再方法执行过程中，因此 方法栈帧 还在栈上，方法就被替换，所以叫 **栈上替换**
  * 该编译动作由**方法内部的循环体**触发，但会**编译整个方法**
* 热点探测
  * 基于采样的热点探测
    * 周期性检查各线程栈顶，方法经常出现则为热点方法
    * 优势：能获取方法调用关系，实现简单
    * 劣势：不精确
  * 基于计数器的热点探测
    * 虚拟机为每个方法/代码块 建立计数器，统计执行次数，次数超过阈值，则为热点方法
    * 优势：精确
    * 劣势：不饿能获取方法调用关系，实现麻烦
  * HotSpot热点探测
    * 基于计数器
    * 每个方法两个计数器
      * 方法调用计数器
      * 回边计数器
    * 方法调用计数器：
      * 统计的式频率，是一定时间内执行的次数
      * 超过时间限定，计数器减半--称为热度衰减【垃圾收集时进行】
      * 两计数器之和超过阈值，触发编译
    * 回边计数器：
      * 统计**一个方法**中**循环体**执行次数/回边的次数/控制流向后跳转的次数
      * 回边计数器阈值计算：
        * C1:方法调用计数器阈值*OSR比率 /100 ;默认：1500 * 140 /100
        * C2:方法调用计数器阈值*（OSR比率 - 解释器监控比率） /100；默认：10000 * （140 - 13） /100
      * 两计数器之和超过阈值，触发OSR编译，降低回边计数器值使得再编译好前能使用解释方式继续执行

---

##### 3.1.3. 编译过程

* C1
  * 三段式编译器
    * 第一阶段，将**字节码** 构造成一种 **高级中间代码表示HIR**
    * 第二阶段, 从HIR中产生**低级中间代码表示LIR**
    * 第三阶段，使用**线性扫描算法**在LIR上分配寄存器，做窥孔优化，并生成机器代码
  * 关注局部优化
* C2
  * 进行经典优化，进行激进优化

---

#### 3.2. 编译优化技术

##### 3.2.1. 公共子表达式消除

* 如果一个表达式E已经计算过了，后来再次出现了，且两次E中的所有变量都没变化，则再次出现的E就是公共子表达式
* 局部公共子表达式消除：限于程序的基本块内
* 全局公共子表达式消除：优化涵盖多个基本块

---

##### 3.2.2. 数组边界检查消除

* Java访问数组时，系统会自动进行上下界范围检查，这算隐式开销
* 通过将检查从运行期提前到编译器完成

---

##### 3.2.3. 方法内联

* 把目标方法中的代码 复制 到发起调用的方法中

* 好处
  * 消除方法调用成本
  * 为其他优化手段打基础
* Java中默认的**实例方法**时虚方法，编译器做内联时，无法确定该使用那个版本，只能在运行期确定
* 类型继承关系分析CHA: 基于整个应用进行类型分析
* 内联过程：
  * 如果是非虚方法，可直接内联
  * 如果是虚方法，向CHA查询此方法在当前程序中是否有多个目标版本可选择
  * 如果只查询到一个版本，进行内联，属于激进优化，需要逃生门，也称其为守护内联
    * 如果虚拟机没加载了的导致继承关系发生变化的新类，内联优化就可以持续
    * 如果虚拟机加载了的导致继承关系发生变化的新类，则抛弃已经编译的代码，回退解释执行/重新编译
  * CHA查询到多个版本，使用内联缓存 来完成方法内联
    * 第一次调用后，缓存记录方法接收者的版本信息
    * 每次方法接收者都一致，则内联可用
    * 方法接收者不一致，取消内联，查找虚方法表进行方法分派

---

##### 3.2.4. 逃逸分析

* 不直接优化代码，为其他优化提供优化依据
* 逃逸分析 分析的基本行为：分析对象动态作用域，一个对象在方法内被定义后，可能被外部方法引用；逃逸分析就是证明一个对象不会逃逸
* 方法逃逸：对象作为参数，被传递到其他方法
* 线程逃逸：对象被外部线程访问到
* 没有逃逸，可进行的优化：
  * 栈上分配
    * 好处：让对象在栈上分配，对象所占内存空间随栈帧出栈而销毁，避免了垃圾收集
  * 同步消除
    * 好处：变量不会逃逸，则变量不会有竞争，就不需要同步措施
  * 标量替换
    * 标量：没法分解的数据，如原始数据类型
    * 聚合量：数据可以分解，如对象
    * 将一个Java对象拆散，将其使用到的成员变量替换为原始类型来访问，称为**标量替换**
    * 好处：对象不会逃逸，则可不创建对象，而用访问标量替换对对象的访问，标量分配也会在栈上分配，避免垃圾回收
    * 感觉是栈上分配的更进一步

---

### 4. 常见面试题

* 

### 5. 综述

* 

### 6. 参考资料

* 《深入Java虚拟机-JVM高级特性与最佳实践》
