## 线程安全

### 1. 定义及用途

* 一个对象能够安全的被多个线程同时使用，且调用这个对象的行为都会获得正确的结果，这就是线程安全

### 2. 相对同类产品优势

* 

### 3. 核心知识点

#### 3.1. Java中的线程安全

* 把Java中操作线程共享数据的**安全程度**分为5类
  * 不可变；绝对线程安全；相对线程安全；线程兼容；线程对立

##### 3.1.1. 不可变

* 不可变的对象一定是线程安全的
* 基本数据类型的不可变：定义时使用final关键字
* 对象的不可变：保证对象的行为不会对对象的状态造成影响，如java.lang.String类的对象
  * 保证对象的行为不会对对象的状态造成影响的途径：
    * 把对象中带有状态的变量都声明为final
* Java符合不可变的API:Long Double BigInteger BigDecimal等

---

##### 3.1.2. 绝对线程安全 & 相对线程安全

* 绝对线程安全：多线程访问，不考虑线程运行环境的调度和交替执行，不需要额外同步或其他协调操作，调用对象的行为都可以获得正确的结果

* 相对线程安全：保证对对象**单独的操作**是线程安全的；调用某一个方法/执行某一个行为是线程安全的就够了

---

##### 3.1.3. 线程兼容 & 线程对立

* 线程兼容：对象本身不是线程安全的；调用端正确使用同步手段 保证对象在并发环境 可以安全调用
* 线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码
  * 举例：System.setIn()--重新分配“标准”输入流

---

#### 3.2. 线程安全的实现方法

##### 3.2.1. 互斥同步

* 同步：指多个线程并发访问共享数据时，保证共享数据同时只被一个线程使用
* 互斥：是实现同步的一种手段；互斥是因，同步是果；互斥是方法，同步是目的；
  * 互斥的几种实现方式：临界区、互斥量、信号量
* Java的互斥同步-synchronized：
  * 在同步块前后的字节码中产生monitorenter和monitorexit指令，
  * 这个两个指令都需要一个ref类型的参数来指定要锁定和解锁的对象
    * 使用时指定了对象就用指定对象 作为锁对象
    * 没指定对象，实例方法，就用实例对象 作为锁对象
    * 没指定对象，类方法，就用类的Class对象 作为锁对象
  * 执行monitorenter，获取锁对象，已经获取则锁的计数器+1
  * 执行monitorexit，锁的计数器-1，计数器值为0，释放锁对象
  * 产生耗时操作：Java的线程映射到系统的原生线程，所以线程的阻塞唤醒都需要操作系统帮忙完成，也就涉及从用户态到内核态的切换，而状态转换会耗费很多处理器时间
* Java的并发包中的可重入锁-ReentrantLock
  * 与synchronized相似，多了些功能：
    * 等待可中断：等不了了，可以主动中断放弃等待
    * 可实现公平锁，避免饥饿：多个线程按照等待顺序获取锁
    * 锁可以绑定多个条件：可以绑定多个Condition对象，可以更细微的控制锁
* 问题：线程阻塞和唤醒会带来性能问题，所以互斥同步又称阻塞同步
* 互斥同步属于悲观的并发策略，总认为不同步会出问题，这种情况使用的锁可称为 悲观锁

---

##### 3.2.2. 非阻塞同步

* 基于冲突检测的乐观并发策略：总认为不同步也不出问题；先操作，没有竞争则操作成功；共享数据有竞争，再重试
* 非阻塞同步：乐观的并发策略不需要挂起线程，所以称为 非阻塞同步
  * 建立在操作和冲突检测 这两个步骤一起具有原子性，这需要硬件来完成
  * 硬件能保证将看似需要多条操作的行为 只通过一条指令完成，此类指令有：
    * 测试并设置
    * 获取并增加
    * 交换Swap
    * 比较并交换CAS-Compare and Swap
    * 加载连接/条件存储 LL/SC
* CAS指令：
  * 需要3个操作数：内存地址/变量的内存地址，旧的预期值，新值
  * 只有旧的预期值 匹配变量的值时，才将新值赋给变量；否则不执行更新；最终均返回变量的旧值
  * Java中的CAS操作由sun.misc.Unsafe类的compareAndSwapXXX()方法提供
  * Unsafe不直接提供给用户调用；可以使用正数原子类，里面调用了Unsafe的CAS操作
  * CAS操作会由ABA问题：给变量值以版本或计数器来保证CAS的正确性

---

##### 3.2.3. 无同步方案

* 线程安全不一定非要同步，若不涉及共享数据，则天生线程安全
* 可重入代码/纯代码：返回结果可预测，输入相同数据得到相同结果
  * 不依赖存储在堆上的数据 & 公用的系统资源
  * 用到的状态量由参数传入
  * 不调用非可重入方法
* 线程本地存储：把共享数据的可见范围限制在一个线程内，使用线程本地存储来解决线程安全问题
  * Java语言的java.lang.ThreadLocal类实现了线程本地存储的功能，该类型的变量每个线程都会有一份

---

### 4. 常见面试题

### 5. 综述

### 6. 参考资料

* 《深入Java虚拟机-JVM高级特性与最佳实践》