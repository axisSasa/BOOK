## 类加载机制

### 1. 定义及用途

* 虚拟机把描述类的数据 从Class文件 加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制
* Java语言里面，类型的加载、连接和初始化过程都是在程序**运行期**完成的

### 2. 相对同类产品优势

* 其他语言可能需要在编译时就进行连接，Java则在运行时进行连接；相对而言增加了性能开销，但提供了高度的灵活性

### 3. 核心知识点

#### 3.1. 类加载的时机

##### 3.1.1. 类的生命周期

* 共7个阶段：加载-验证-准备-解析-初始化-使用-卸载
* 其中验证-准备-解析 统称为 连接 阶段
* 其中5个阶段开始的先后顺序固定：加载-验证-准备-*-初始化-*-卸载
* 不固定的：解析可以在初始化后再开始--这个特性支持了动态绑定

---

##### 3.1.2. 类的初始化时机

* 类初始化阶段，有且只有在以下5中情况才开始【也只会初始化一次】
  * 遇到new, getstatic, putstatic, invokestatic 这4条字节码指令时
    * 使用new关键字
    * 读取或设置 一个类的 静态字段【且该静态字段是非final修饰的】
    * 调用一个类的静态方法
  * 使用java.lang.reflect 包的方法对类进行 **反射调用** 的时候
  * 初始化一个类，发现其父类还未初始化，则先触发父类初始化
  * 虚拟机启动时，用户指定的执行主类
  * **待完善**。。。
* 主动引用：能触发类初始化阶段的行为 被称为 一个类进行**主动引用**
* 被动引用：引用类的方式没有导致类初始化，称为**被动引用**
* 被动引用举例
  * 通过 子类 引用 父类的静态字段，不会导致子类初始化，父类会初始化
  * 通过数组定义 来引用类， 不会触发此类的 初始化
  * 常量在百衲衣阶段会存入**调用类**的常量池中，所以 常量没有直接引用到 **定义常量的类**，不会触发定义常量的类的初始化
    * 因为编译阶段通过常量传播优化，该常量值会存入到 调用类的常量池中
    * 事实上，编译后，调用类中没有 定义常量的类 的 符号引用
    * 换句话说， 这种情况下， 调用类 和 定义常量的类 没有关系
* 接口加载过程特别说明：
  * 接口在初始化时，不要求 父接口 全部都完成初始化
  * 只有在使用到父接口的时候才会初始化

---

#### 3.2. 类加载的过程

* 加载-验证-准备-解析-初始化

##### 3.2.1. 加载

* 加载阶段虚拟机任务：
  * 通过一个类的 **全限定名** 获取定义此类的 **二进制字节流**
    * 从ZIP包读取-WAR,JAR
    * 从网络中获取-applet
    * 运行时计算生成-动态代理
    * 由其他文件生成-jsp
  * 将**字节流 所代表的 静态存储结构** 转化为 **方法区的 运行时数据结构**
  * 在内存中 生成一个代表这个类的 java.lang.Class对象
    * HotSpot中Class对象不再堆中，而在方法区
* 数组类：
  * 数组类不由类加载器创建，而由Java虚拟机直接创建
  * 数组类中的元素类型 由 类加载器 创建

---

##### 3.2.2. 验证

* 连接阶段的第一步
* 验证阶段任务：确保Class文件的字节流包含的信息 符合当前虚拟机的要求
* 验证阶段大致完成4个检验动作：
  * 文件格式验证
    * 验证 字节流
    * 目的：保证输入的字节流能正确的解析 并存储于方法区之内
    * 验证时机：在加载阶段
    * 通过这个验证，【加载阶段的】字节流才会进入方法区进行存储
  * 元数据验证
    * 验证 方法区的数据结构
    * 任务: 对字节码描述的信息 进行语义分析
    * 目的：对类的元数据进行校验，保证不存在不符合Java语言规范的元数据信息
  * 字节码验证
    * 验证 方法区的数据结构
    * 任务：对类的方法体 进行校验分析，保证运行安全
    * 目的：通过 数据流&控制了分析，确定程序语义合法
  * 符号引用验证
    * 验证 方法区的数据结构
    * 验证时机：虚拟机将 符号引用转化为 直接引用时/在解析阶段发生
    * 任务：对类自身之外的信息 进行匹配性校验
    * 目的：确保解析动作能 政策执行
* 验证阶段 是 重要 但 不必要的。省略验证阶段 可 缩短 

---

##### 3.2.3. 准备

* 连接阶段的第二步
* 准备阶段的任务：为 类变量 分配内存，并设置类变量初始值
  * 类变量 初始值：
    * 一个字段只被static修饰，具体的赋值动作在初始化阶段 进行，**准备阶段**为初始零值；
    * 一个字段同时被static和final修饰，且该字段为基本类型或者String时，才生成ConstantValue来初始化；**准备阶段**为初始化值；
    * 一个字段同时被static和final修饰，但该字段不为基本类型或者String时，在<clinit>方法中赋值；**准备阶段**为零值；
  * 非static修饰【非类变量】
    * 则在实例构造器方法<init>中进行赋值；准备阶段不进行赋值

---

##### 3.2.4. 解析

* 连接阶段的第三步
* 解析阶段的任务：将常量池内的 符号引用 替换为 直接引用
* 符号引用：
  * 在Class文件中以CONSTSNT_Class_info【类或接口的符号引用】等类型的常量出现
  * 可以用一组符号来描述 引用的目标；
  * 可为任意形式的字面量，但需无歧义；
  * 与虚拟机实现的内存布局无关；
  * 引用目标不一定已经加载到内存中
* 直接引用：
  * 可以是直接指向目标的指针；
  * 相对偏移量或一个能间接定位到目标的句柄；
  * 与虚拟机实现的内存布局有关；
  * 引用目标一定在内存中
* 解析阶段发生时间：
  * 在执行用于 操作符号引用的字节码指令之前
  *  操作符号引用 的字节码指令：getstatic instanceof invokedynamic 等之前
* 7种符号引用的解析：
  * 类或接口的解析- D类中的符号引用N，解析为类C的直接引用
    * 虚拟机把代表N的全限定名传给D的类加载器,这个类加载器去加载类C
    * 加载过程中，可能触发其他相关类的加载
    * 加载未出现异常，类C在虚拟机中实际上已经成为一个有效的类了
    * 在解析结束前，还要进行符号引用验证，确保D具备对C的访问权限
  * 字段解析-类C的字段
    * 解析字段前，需要成功解析字段所属的类C
    * 对类C进行字段搜索
      * C本身包含了 简单名称和字段描述符都与目标相匹配的字段，返回这个字段的直接引用，查找结束
      * 否则，如果C实现了接口，则按继承关系从下往上递归搜索，如果某个接口中包含了  简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
      * 否则，如果C不是java.lang.Object的话，按照继承关系，从下往上递归搜索，如果某个父类包含了 简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
      * 否则 查找失败，抛出java.lang.NoSuchFieldError异常
      * 且，如果查找中成功返回直接引用，将会对这个字段进行权限验证
  * 类方法解析
  * 接口方法解析
  * 方法类型解析
  * 方法句柄解析
  * 调用点限定符解析

---

##### 3.2.5. 初始化

* 类加载过程的最后一步
* 初始化阶段：开始执行类中定义的Java代码【字节码】
* 任务：执行类构造器<clinit>()方法
* <clinit>()方法：
  * 由**编译器** 自动收集 类中的所有**类变量的赋值动作**和静态语句块【static{}】中的语句合并产生
    * 定义在静态语句块A之后的变量，在静态语句块A中只能被赋值，不能访问
  * <clinit>()不需要显示的调用父类类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()已经被执行；
    * 相对的，实例构造器<init>()方法，需要显示调用
  * <clinit>()可以没有
  * 接口中，不能使用静态语句块，但接口中任然有变量初始化的赋值操作
    * 接口可以生成<clinit>()方法
    * 接口<clinit>()方法执行前，不需要先执行父接口，只有在使用的时候，父接口才初始化；接口的实现类同理
  * 虚拟机会保证一个类的<clinit>()方法在多线程的情况下正确运行，也就是会加锁，同步；若多个线程同时访问<clinit>()，且<clinit>()执行时间太长，可能造成进程阻塞

---

#### 3.3. 类加载器

* 在类加载阶段的最开始需要“通过一个类的 **全限定名** 获取定义此类的 **二进制字节流**”，实现这个动作的就是**类加载器**

##### 3.3.1. 类与类加载器

* 类在Java虚拟机中的**唯一性**由类和加载类的类加载器共同确定
* 每个类加载器都有一个独立的类名称空间，由不同类加载器加载的类在虚拟机中位于不同的命名空间下，不同命名空间下的类相互不可见
* 比较两个类相等，须在同一个类加载器加载的前提下才有意义
  * Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法
  * instanceof关键字

---

##### 3.3.2. 双亲委派模型

* 类加载器详解
  * 按是否是虚拟机一部分，分为
    * 启动类类加载器：是虚拟机的一部分
    * 启动类类加载器之外的其他类加载器：独立于虚拟机外部，全部继承自java.lang.ClassLoader
  * 启动类加载器
    * 加载<JAVA_HOME>\lib中的虚拟机能够识别的类库到虚拟机内存中
    * 加载被-Xbootclasspath参数指定的路径中的虚拟机能够识别的类库到虚拟机内存中
    * 启动类加载器无法被Java程序直接引用
  * 扩展类加载器
    * 负责加载<JAVA_HOME>\lib\ext目录中的库类
    * 负责加载被java.ext.dirs系统变量所指定的路径中的类库
    * 可直接使用
  * 应用程序类加载器
    * 也称为：系统类加载器
    * 用于加载用户路径上所指定的类库
    * 程序中的默认类加载器
    * 是ClassLoader中getSystemClassLoader()方法的返回值
* 双亲委派模型
  * 定义：类加载器之间的层次关系，称为类加载器的双亲委派模型
  * 要求：除了启动类加载器外的类加载器都应有自己的爸爸
  * 工作过程：类加载器都把加载的请求先交给爸爸加载，爸爸没法加载，儿子才会尝试加载
  * 好处：Java类和其类加载器一起具备了 一种带优先级的 层次关系
    * java.lang.Object在rt.jar中，无论那个类加载器加载它们都会委派给处于 双亲委派模型最顶端的启动类加载器 进行加载；保证了Object类在各种类加载器环境中都是同一个类
  * 运行逻辑：
    * 先检查是否已经被加载；
    * 没有，则调用父加载器的loadClass()方法
    * 若父加载器为空，则默认使用启动类加载器作为 父加载器
    * 若父加载器加载失败，抛出异常，再调用自己的findClass()方法进行加载

##### 3.3.3. 破坏双亲委派模型

### 4. 常见面试题

* 

### 5. 综述

* 

### 6. 参考资料

* 《深入Java虚拟机-JVM高级特性与最佳实践》
* [JAVA 不同类加载器命名空间的理解](https://blog.csdn.net/shiziaishuijiao/article/details/40804161)
* 