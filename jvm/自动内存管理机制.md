## 自动内存管理机制

### 1. 定义及用途

* Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。
* 在整个程序**执行过程中**，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存
* Java虚拟机会把它管理的内存划分为不同的数据区域【运行时数据区】，各个数据区域用途、创建及销毁时间都有差异

### 2. 相对同类产品优势

* 暂无

### 3. 核心知识点

#### 3.1. Java虚拟机运行时各数据区域

##### 3.1.1. 程序计数器

- 英文：Program Counter Register
- 类型：是线程隔离【私有】的数据区
- 创建：依赖线程的启动而创建
- 销毁：依赖线程的结束而销毁
- 用途：用作**当前线程**执行的**字节码**的**行号指示器**；执行Java方法时，记录的是正在执行的虚拟机字节码指令地址
- 具体用处：线程切换后能依靠程序计数器恢复到正确的执行位置
- 异常：无
- 引申：[JVM 程序计数器](https://blog.csdn.net/leaf_0303/article/details/78953669)

---

##### 3.1.2. Java虚拟机栈

- 英文：Java Virtual Machine Stacks
- 类型：是线程隔离【私有】的数据区
- 创建：依赖线程的启动而创建
- 销毁：依赖线程的结束而销毁
- 用途：为虚拟机执行Java方法服务
- 具体用途：是**Java方法**执行的内存模型；虚拟机栈的**栈元素**是**栈帧**，每一个**Java方法**执行时会创建一个**栈帧**，**栈帧**入栈【Java虚拟机栈】，执行完成，**栈帧**出栈
- 栈帧： 存储 **局部变量表**，**操作数栈**，动态链接，方法出口。。。
- 局部变量表：
  - 局部变量表中变量的存放顺序为： this（如果是实例方法）=> 参数（如果有的话）=> 定义的局部变量（如果有的话）；
  - 可存放**编译器可知**的基本数据类型【8种】、对象引用、returnAddress类型；
  - 特点：局部变量表所需内存空间在编译期完成分配
- 操作数栈：
  - 存放操作数；
  - 当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果（如果有的话）入栈
- 异常：StackOverflowError【请求栈深度>虚拟机栈深度】、OutOfMemoryError【虚拟机栈动态扩展，无法申请到足够内存】
- 引申：[探究 Java 虚拟机栈](http://www.importnew.com/26842.html)

---

##### 3.1.3. 本地方法栈

- 英文：Native Method Stack
- 类型：是线程隔离【私有】的数据区
- 用途：为虚拟机执行的**Native方法**服务
- Native方法：一般是C语言之类的实现的，举例：`public native int hashCode();` 
- 异常：StackOverflowError、OutOfMemoryError

---

##### 3.1.4. Java 堆

- 英文：Java Heap / Garbage Collected Heap
- 类型：所有线程**共享**的内存区域
- 创建：虚拟机启动时创建
- 销毁：虚拟机进程关闭
- 用途：存放**对象实例**+数组
- 内存空间：要求逻辑上连续，物理上可不连续的空间
- 异常：OutOfMemoryError

---

##### 3.1.5. 方法区

- 英文：Method Area
- 类型：所有线程**共享**的内存区域
- 创建：虚拟机启动时创建
- 销毁：虚拟机进程关闭
- 用途：存放虚拟机加载的1.类信息,2.常量,3.静态变量,4.即时编译器编译后的代码。。。
- 内存空间：要求逻辑上连续，物理上可不连续的空间，可不实现垃圾回收
- 运行时常量池：存放Class文件中的描述的符号引用，翻译出来的直接引用；特点：运行期也能将新的常量放入运行时常量池中
- Class文件常量池： Class文件中含有用于存放编译期生成的各种字面量和符号引用的**常量池**
- 异常：OutOfMemoryError

---

#### 3.2. 非Java运行时数据区-直接内存

- 英文：Direct Memory
- 类型：**不是**Java运行时数据区的一部分
- 特点： 内存分配不受Java堆限制，只受本机总内存限制
- 异常：OutOfMemoryError

---

#### 3.3. HotSpot虚拟机中得对象数据

> Java虚拟机中的数据，如何创建？如何布局？如何访问？

##### 3.3.1. 普通Java对象得创建

> new指令的执行

- 

- 类加载：
  1 检查new指令的参数**是否**能在**运行时常量池**中定位到一个**类的符号引用**
  2 检查这个**类的符号引用**代表的类**是否**已被加载、解析、初始化【是否走完类加载过程】
  3 如果没有，则必须先执行相应类加载过程
- 为新生对象分配内存-从Java堆中划分一块确定大小的内存
  1 Java堆内存绝对规整：**指针碰撞**
  2 Java堆内存不规整：**空闲列表**
  3 Java堆内存是否规整：由采用的垃圾收集器是否带有**压缩整理**功能决定
  4 指针碰撞： 空闲的内存是规整的，向空闲内存移动与对象大小相等的距离
  5 空闲列表：空闲的内存不规整，建立一个列表记录可用内存块，找到足够建立新对象的内存块划分给对象实例
- 并发情况下，分配内存线程不安全的解决方案
  1 对分配内存空间的动作进行**同步处理**：CAS方式分配空间，失败则重试
  2 把内存分配动作按照线程划分在**不同的空间进行**：各线程在Java堆中预留一块内存【本地线程分配缓冲TLAB】，自己线程要分配内存就在预留的内存上分配；优势：只有TLAB用完分配新的TLAB时，才需要同步锁定
- 将内存空间初始化为零值【不包括：对象头】
  1 执行时间：可在上一步骤分配TLAB时就进行初始化为零值
  2 好处：保证对象实例字段在Java代码中不赋初始值就可使用
- 对对象进行必要设置【设置对象头】

---

##### 3.3.2. 对象的布局

> 对象在内存中的布局分为3块区域：对象头、实例数据、对齐填充

- 对象头：包含两部分信息
  1 对象头第1部分：存储对象自身的运行时数据【Mark Word】;特点：非固定数据结构，可根据对象状态复用自己的存储空间
  2 对象头第2部分：类型指针，对象指向它的类元数据的指针【虚拟机可凭此确定对象是哪个类的实例】
  3 如果是数组-对象头有第3部分：记录数组长度；Java对象的元数据能确定自己的大小，数组不能
- 实例数据：程序定义的各个字段的内容
  1 实例数据存储顺序：由虚拟机分配策略参数和字段在Java源码中的定义顺序决定
  2 HotSpot虚拟机分配策略为：long/double int short/char byte/boolean oop;特点：相同宽度的字段总分配在一起
- 对齐填充
  1 来源： HotSpot自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象头是8字节的整数倍，实例数据部分大小不是8字节的整数倍时，用对齐填充来补全
  2 作用：不是必然存在，只起占位符的作用

---

##### 3.3.3. 对象得访问定位

> Java使用对象就是通过栈上的引用来操作堆上的具体对象

- 主流的对象访问方式
  1 使用句柄：栈上引用存放的是对象的**句柄地址**；可从句柄地址获取到**对象实例数据**的指针&到**对象类型数据**的指针；特点：Java堆需划分一块内存做**句柄池**
  2 直接指针：栈上引用存放的是**对象地址**
- 主流的对象访问方式优势
  1 使用句柄：垃圾收集时，对象被移动，只会改变句柄中的实例数据指针，对象引用不需修改
  2 直接指针：访问速度快，比使用句柄少了一次指针定位

### 4. 常见面试题

* 你了解Java内存模型么？
* 讲讲程序内存的分布，5个部分？

### 5. 综述

* Java内存模型是JVM的基础知识，了解了能更利于理解JVM如何执行代码

### 6. 参考资料

* 《深入Java虚拟机-JVM高级特性与最佳实践》
* [Java面试--Java内存模型](https://blog.csdn.net/weixin_41835916/article/details/81434915)

