## 锁优化

### 1. 定义及用途

* 为了线程间高效的共享数据&解决竞争问题，从而提高程序的执行效率

### 2. 相对同类产品优势

* 

### 3. 核心知识点

#### 3.1. 自旋锁 & 自适应自旋

* 自旋锁：
  * 定义：多个线程并发执行时，让后面请求锁的线程稍等以下，但不放弃处理器的执行时间，因为共享数据的锁定状态通常持续很短，可能持有锁的线程很快会释放锁，要让线程等待只需让线程执行一个忙循环（自旋），所以叫自旋锁
  * 前提：物理机得有**一个以上**的处理器，才能让两个线程同时**并行**执行
  * 好处：避免了挂起&恢复线程；避免了线程切换的开销
  * 缺点：有处理器数量要求；自旋等待本身占用处理器时间
  * 适用情形：锁占用时间短
  * 自旋等待限度：自旋超过限定次数，则挂起线程
* 自适应自旋锁：自旋时间不固定，由前一次在同一个锁上的自旋时间&锁拥有者状态 决定；

#### 3.2. 锁消除

* 定义：虚拟机JIT运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁 进行消除
* 锁消除判断依据：逃逸分析，如果一段代码所有数据都不会逃逸出去，则不会被其他线程访问到，就可以当作时栈上数据来对待【栈上替换，标量替换等可能直接就优化掉了】，可认为是线程私有的，则无需同步
  * 很多同步都不是程序员自己加入的，可能是编译器优化后产生的
  * 如字符串+，编译后为StringBuilder的append()方法，而append()方法中就有同步块

#### 3.3. 锁粗化

* 原则上：同步块的作用范围应该尽可能小，只在共享数据的实际作用域才进行同步，使得同步块尽量小，尽快执行，其他线程能更快拿到锁
* 锁粗化：
  * 定义1：把加锁同步的范围扩大，减少加锁次数，提升性能，就是锁粗化
  * 定义2：在有一系列连续操作都对同一个对象反复加锁&解锁，或者一段代码内多次反复加锁解锁，频繁的进行互斥同步操作导致不必要的新年损耗，可以让加锁的范围扩大，这样只消耗一次加锁解锁，这就是锁粗化

#### 3.4. 轻量级锁

* 轻量级锁的轻量：相对于使用OS互斥量来实现的传统锁【如 synchronized的锁】而言，减少性能消耗

* 目的：在没有多线程竞争的前提下，减少重量级锁 使用操作系统互斥量 产生的性能消耗
* 优势：没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，
* 缺点：存在竞争则会多出CAS操作，此时必重量级锁更慢
* 存在意义：经验数据表明大部分锁在整个同步周期内都是不存在竞争的，所以使用轻量级锁很大程度上能提升程序的性能
* 轻量级锁加锁过程
  * 进入同步块，同步对象**未锁定** 【标志位为01】VM在当前线程的栈帧中建立锁记录【存储锁对象Mark Word的拷贝，称为 Displaced Mark Word】
  * VM 使用CAS操作尝试 更改对象的**Mark Word**为 指向锁记录的**指针** 
  * 若更新成功，线程获得该对象的锁，并将对象Mark Word的锁标志位 转变为 00，即：**轻量级锁定**
  * 若更新失败，VM先检查对象的Mark Word是否指向 当前线程的栈帧
  * 如果是，则说明当前线程已经拥有该对象的锁，可以直接进入同步块执行
  * 如果否，则说明这个锁对象已经被其他线程抢占，轻量级锁膨胀为重量级锁，锁标志位转变为10，此时Mark Word中存储的是指向重量级锁的指针，等待该锁的线程则进入阻塞状态
* 轻量级锁解锁过程
  * 如果对象的Mark Word仍然指向 线程的锁记录，用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word 替换回来
  * 如果替换成功，同步过程就完成了
  * 如果替换失败，说明其他线程尝试过获取该锁【Mark Word指向重量级锁了】，释放锁的同时需要要唤醒被挂起线程

#### 3.5. 偏向锁

* 目的：消除数据在无竞争情况下的同步元语，能看似把整个同步块都消除掉，比起轻量级锁来说连CAS操作也不用，进一步提高性能
* 偏向锁：
  * 进入偏向模式：偏向锁会偏向于第一个获得该锁的线程，执行过程中该锁没有被其他线程获取，则持有偏向锁的线程永远不再进行同步；
  * 撤销偏向：但当另一个线程尝试获取这个锁时，偏向模式结束，
  * 撤销偏向后：恢复到未锁定或轻量级锁定状态【依据**对象是否已锁定**而异】
* 意义：提高带有同步但无竞争的程序的性能
* 注意：虽然线程持有偏向锁，但锁对象不一定被该线程锁定，偏向锁是根据Mark Word中第一次获取锁的线程的ID记录 才能**不获取锁对象**进入同步块，即所谓的不再进行同步

### 4. 常见面试题

### 5. 综述

### 6. 参考资料

* 《深入Java虚拟机-JVM高级特性与最佳实践》