## 垃圾收集器&内存分配和回收策略

### 1. 定义及用途

* 虚拟机能够使用的内存是有限，程序运行时会产生大量的对象，其中的对象很多已经死亡，需要清理死亡的对象，使得新建对象有内存可用，所以就需要垃圾收集器来完成 内存回收的工作

### 2. 相对同类产品优势

* 比起C++手动分配，手动释放，编程更轻松，也避免了很多忘记释放内存导致的问题，但一旦出了相关问题，排查来又会比较麻烦，需要对正在使用的GC有清晰的认识，这一方面又增加了开发者的精力投入

### 3. 核心知识点

#### 3.1. 哪些**内存分配回收**具有确定性？

* 程序计数器、虚拟机栈、本地方法栈

---

#### 3.2. 怎么判断**Java堆里面的对象是否存活**？

##### 3.2.1. 判断对象是否存活的算法 

* 引用计数法、可达性分析算法 

###### 3.2.1.1. 引用计数算法

* 每个对象添加一个引用计数器；
* 有一个地方引用它，计数器值+1，一个引用失效，计数器值-1；
* 计数器值为0时，对象死亡 

###### 3.2.1.2. 引用计数算法的缺点？

* 很难避免对象之间相互循环引用导致计数器值永不为0 

###### 3.2.1.3. 可达性分析算法

* 一个对象到GC Roots没有任何引用链相连，则该对象不可达 

###### 3.2.1.4. 哪些对象可以充当GC Roots? 

* 虚拟机栈中引用的对象 
* 方法区中 类静态属性引用的对象 & 常量引用的对象 
* 本地方法栈中 JNI(Native 方法)引用的对象 

---

##### 3.2.2 什么是引用？ 

* 引用类型数据中存储的数值代表的是另一块内存A的起始地址，就称这块内存A代表着一个引用(或者说被引用) 

###### 3.2.2.1 Java有哪些引用？

* 强引用、软引用、弱引用、虚引用

###### 3.2.2.2. 强引用when被回收？ 

* 只要强引用还在，垃圾收集器永远不会回收 

###### 3.2.2.3. 软引用when被回收?

* 在将要发生内存溢出异常之前，把软引用对象进行二次回收;回收后内存还不够再抛出内存溢出异常

###### 3.2.2.4. 弱引用when被回收？ 

* 生存到下一次垃圾回收之前

###### 3.2.2.5. 虚引用的特点&作用？

* 无法通过虚引用来取得一个对象实例;
* 在虚引用被会激起回收时能收到一个系统通知

---

##### 3.2.3. Java堆对象如何定生死？ 

* 通过两次标记的结果来确定对象是否被回收；

* 第一次标记：
  * 对象在进行可达性分析后，发现没有与GC Roots相连接的引用链,则进入是否执行finalize()方法筛选
  * 是否执行finalize()方法筛选：若一个对象覆盖了finalize()方法，且这个finalize()方法没有被虚拟机调用过，则将该对象判定为：有必要执行finalize()方法，这个对象也将被放置在F-Queue的队列，并开启单独线程执行finalize() 
* 第二次标记：若对象在执行finalize()中成功和引用链上的对象建立关联,该对象会被移出即将被回收的对象的集合,其他在这个回收集合中的对象就回收了，或者说死了

---

##### 3.2.4. 方法区的内存回收 

* 主要回收废弃常量和无用的类；
* 在大量使用动态代理、反射等的时候需要具备堆无用类的内存回收 

* 怎么判断一个类时无用的类？
  * 该类所有实例被回收 
  * 加载该类的类加载器被回收 
  * 该类对应的Class对象没有被引用

---

#### 3.3. 常见**垃圾收集算法**？

* 标记-清除算法、复制算法、标记-整理算法、分代收集算法

##### 3.3.1. 标记-清除算法

* 过程：
  * 首先标记要回收的对象；
  * 标记完成后统一回收
* 问题：
  * 标记和清除过程效率都不高
  * 产生大量不连续的内存碎片 => 分配较大对象，找不到足够大的连续内存，提前触发垃圾回收

---

##### 3.3.2. 复制算法 

* 过程：
  * 可用内存按容量分为大小相等的两块；
  * 每次使用其中一块，该块内存用完了就将其中存活的对象**复制**到另一块内存；
  * 把使用过的内存空间全部清理掉 
* 优势：没有内存碎片化的问题；效率也高 
* 问题：每次能使用的内存缩小为一半，代价太高
* 回收新生代内存的复制算法：
  * 因为大部分对象死的快，所以不用1:1划分内存空间，将内存分为一块Eden空间和两块Survivor空间；
  * 每次使用Eden空间和一块Survivor空间；
  * 回收时将存活的对象复制到另一块Survivor空间；
  * 清理掉使用了的内存空间；
  * Survivor不够用，多的存活对象则通过分配担保机制进入老年代

---

##### 3.3.3.  标记-整理算法

* 针对：堆笑存活率较高的老年代 

* 过程: 
  * 首先标记要回收的对象;
  * 让存活对对象移动到一端；
  * 清理端边界之外的内存 

---

##### 3.3.4. 分代收集算法 

* 过程：
  * 根据对象存活周期，将Java堆分为新生代和老年代；
  * 不同代根据自身特点选用不同算法

---

#### 3.4. HotSpot的算法实现-进入GC

##### 3.4.1. 确保一致性

* 可达性分析需要在能**确保一致性的快照**中进行，
* 为了保证一致性GC进行时必须**停顿所有Java执行线程**【Stop The World】 

##### 3.4.2. 安全点

* 停顿后，GC扫描时，虚拟机能直接得知哪些地方存放着对象引用【利用OopMap】，
* 为所有指令都生成OopMap需要大量空间，所以只在**安全点**生成OopMap【根据指令序列复用，选择安全点】 

##### 3.4.3. GC时，所有线程都需处于安全点 

* 抢先式中断：所有线程中断；中断不在安全点，恢复线程跑到安全点 
* 主动式中断：设置标志；线程主动轮询标志；发现中断标志自己中断挂起 

##### 3.4.4. 安全区域

* 线程sleep或者blocked无法相应JVM的中断请求；
* 安全区域就是一段代码中，引用关系不会变化，该区域内开始GC都是安全的

#### 3.5. 垃圾收集器

##### 3.5.1. CMS收集器 

* 英文： CMS-Concurrent Mark Sweep 

* 步骤：初始标记-并发标记-重新标记-并发清除 
  * 初始标记：GC停顿；标记GC Roots能直接关联到的对象 
  * 并发标记：进行GC Roots Tracing过程 
  * 重新标记：GC停顿；修正并发标记期间产生变动的标记记录 
  * 并发清除：清除死掉对象 

* 优势：并发收集、低停顿 

* 缺点：
  * 占用一部分线程，可能导致应用程序变慢；
  * 无法处理浮动垃圾；产生大量碎片

---

##### 3.5.2. G1收集器 

* 英文：Garbage-First 

* 思路：化整为零，内存分为多个Region，优先回收大价值Region 

* 步骤：初始标记-并发标记-最终标记-筛选回收 
  * 初始标记：停顿；标记GC Roots能直接关联到的对象；修改TAMS值-确保并发标记时能在可用Region创建对象 
    * 在GC根节点的枚举范围加入 Remembered Set来保证不对全堆扫描也不会有遗漏
  * 并发标记：可达性分析-并发执行 
  * 最终标记：停顿-并行执行；修正标记变动；记录变化到Remembered Set Logs；整合Remembered Set Logs到Remembered Set中【记录不同堆对象引用，避免全堆扫描】 
  * 筛选回收：对各Region回收价值和成本排序；根据用户期待的GC停顿实际来制定回收计划

---

#### 3.6. 内存分配&回收策略

* Java自动内存管理，可归结为自动化解决两个问题：
  * 给对象分配内存
  * 回收分配给对象的内存
* 内存分配规则
  * 对象优先在Eden分配
    * 多数情况下，对象在新生代Eden区分配，当Eden区没有足够空间进行分配，虚拟机发起一次Minor GC
    * 新生代GC/Minor GC: 指发生在新生代的垃圾收集动作
    * 老年代GC/Major GC/Full GC: 发生在老年代的GC,出现时经常伴随至少一次Minor GC，速度比Minor GC慢10倍以上
  * 大对象直接在老年代分配
    * 可设置一定大小的大对象直接在老年代分配，避免在Eden区和Survivor区之间发生大量的内存复制
  * 长期存活的对象进入老年代
    * 定义对象的年龄计数器
    * 在Eden区出生，并经过第一次Minor GC仍存活，且能被Survivor容纳，将被移动到Survivor空间并设年龄为1
    * 对象在Survivor空间，每经过一次Minor GC,年龄增长1岁
    * 年龄达到晋升老年代的阈值，则进入老年代
  * 动态对象年龄判断
    * 在Survivor空间中 相同年龄A的所有对象大小的总和 > Survivor空间大小的一半 时；年龄 >= A 的对象可以直接进入老年代，不用达到阈值
  * 空间分配担保
    * 能避免频繁Full GC
    * 在 Minor GC 发生之前，虚拟机先 检查 老年代 最大可用的连续空间 是否 > 新生代 所有对象总空间；
    * 如果大于，Minor GC 则是安全的
    * 如果小于，则虚拟机会查看HandlePromotionFaillure是否设置允许担保失败
    * 允许担保失败，检查老年代最大可用连续空间是否 > 历次晋升老年代对象的平均大小
    * 如果大于， 尝试进行Minor GC
    * 如果小于/不允许担保失败，改为进行Full GC

### 4. 常见面试题

* 

### 5. 综述

* 

### 6. 参考资料

* 《深入Java虚拟机-JVM高级特性与最佳实践》

