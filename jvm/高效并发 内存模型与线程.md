## 内存模型与线程

### 1. 定义及用途

* 计算机的运算速度和它的存储和通信子系统的速度差别很大，利用多任务处理能更好发挥处理器的性能
* 服务端需要同时对大量客户端提供服务，使得高效并发必不可少
* 了解Java内存模型，能够帮助更好的理解实现多线程

### 2. 相对同类产品优势

* 

### 3. 核心知识点

#### 3.1. 硬件的效率与一致性

* 高速缓存
  * 背景：计算机的存储设备与处理器的运算速度有几个数量级的差距
  * 高速缓存的读写速度接近处理器的运算速度，所以可以作为内存与处理器之间的缓冲
    * 处理器从高速缓冲存取数据，保证处理器高效运作；高速缓冲再完成对存储设备读写
  * 导致问题：缓存一致性；每个处理器都有自己的高速缓存，但它们共享一块主内存，所以读写时可能造成各个高速缓存数据不一致
  * 解决缓存一致性问题：处理器访问高速缓存时都遵守一些协议，读写时根据协议来操作，如MSI,MESI
  * 物理机器的内存模型：特定的操作协议下，对特定的内存或高速缓存进行读写访问过程的抽象
  * 乱序执行：处理器会对输入代码进行优化，保证结果一致，但不保证中间执行顺序一致；类似于Java虚拟机JIT的指令重排序

---

#### 3.2. Java内存模型

* Java内存模型，JMM
  * 目的：用来屏蔽各种硬件&操作系统的内存访问差异，使得Java程序能在各个平台都实现一致的访问内存的效果
  * 主要目标：定义程序中各个变量的访问规则；即：虚拟机将变量从内存取出/存入内存
    * 涉及变量，包括：实例字段，静态字段，构成数组对象的元素
    * 不包括变量：局部变量&方法参数；它们时线程私有的，不存在竞争

##### 3.2.1. 主内存与工作内存

* 主内存：JMM规定所有变量都存在主内存
  * 线程间变量的传递，必须通过主内存
  * 线程不能直接读写主内存中的变量，线程对变量的操作都在工作内存中进行
* 工作内存：每条线程都有工作内存
  * 工作线程保存该线程使用到的变量的主内存副本拷贝
  * 线程不能直接读写主内存中的变量，线程对变量的操作都在工作内存中进行
  * 不同线程无法直接访问对方工作内存中的变量

---

##### 3.2.2. 内存间交互操作

* 为了主内存与工作内存之间的变量数据同步，保证并发下访问内存是安全的，定义了以下的操作&规则
  * 作用于主内存的变量：
    * lock,把一个变量标志位一条线程独占的状态
    * unlock,把一个处于锁定状态的变量释放出来，释放后，其他线程才能锁定
    * read,把一个变量从主内存 传输到 线程的工作内存
    * write,把store操作从工作内存中获取的变量的值 放入主内存
  * 作用于工作内存的变量：
    * load, 把read操作从主内存得到的变量值 放入工作内存的变量副本中
    * use,把工作内存中的变量值 传递给 执行引擎【使用到变量的值的字节码指令时执行】
    * assign, 把从执行引擎 接收到的值 赋值给 工作内存中的变量【变量赋值的字节码指令时执行】
    * store,把工作内存中的变量的值 传送到主内存中
  * 规则：
    * 不允许read & load 或者 store & write 单独出现
    * 不允许线程丢弃最近的assign操作
    * 不允许没有发生过assign，就同步数据到主内存
    * 一个新的变量只能再主内存诞生，不允许直接load & assign
    * 一个变量同一时刻，值允许一个线程锁定，但可被同一线程重复锁定
    * 线程对一个变量lock，会清空工作内存中的变量值，执行引擎使用前需重新load
    * 变量没被lock，就不允许被执行unlock
    * 变量被执行unlock前，必须被同步会主内存中

---

##### 3.2.3. 对volatile修饰的变量的特殊规则

* volatile关键字 是一种 轻量级的 同步机制
* volatile特性：
  * 保证修饰的变量对所有线程的可见性，但并发运算不一定安全
    * volatile下并发安全的运算：
      * 运算结果不依赖于当前值，或者 能保证只有单一线程修改变量值
      * 变量不需要与其他状态变量 共同参与不变约束
  * 禁止指令重排序
* JMM对volatile变量定义的规则
  * 同一个线程对volatile变量，use前必load,又因load前必read，所以 必定顺序执行 read,load,use
  * 线程对volatile变量执行store必先执行assign，执行assign必执行store，store必立即write
  * 同一线程两个volatile变量，先use则先read;先assign则先write

---

##### 3.2.4. 对long&double型变量的特殊规则

* 非原子性协定：JMM要求lock等8个操作具有原子性，但对于long & double 类型变量，允许虚拟机将未被volatile修饰的64位数据的读写划分为两次32位的操作进行，即不保证64位数据类型的load,store,read,write的原子性
* 实际上，各虚拟机都是原子操作

---

##### 3.2.5. 原子性&可见性&有序性

* 原子性：基本数据类型的访问基本具备原子性/synchronized关键字实现原子性

* 可见性：指 一个线程修改了共享变量的值，其他线程能立即看见/volatile，synchronized，final可实现可见性
* 有序性：线程内的操作都是有序的，毕竟指令重排序不影响结果；线程之间的有序性可通过volatile/synchronized 实现

---

##### 3.2.6. 先行发生原则

* 确定一个访问在并发下是否安全
* happens-before
* 一些天然的先行发生关系，具备顺序性保障
  * 并发时讲过了
* 先行发生与发生时间没关系

---

#### 3.3. Java与线程

* 实现并发不一定依赖多线程；但Java并发与多线程密切相关

##### 3.3.1. 线程的实现

* 实现线程的3中方式：
  * 使用内核线程实现
    * 内核线程KLT:由操作系统内核支持的线程
    * KLT由内核完成线程切换，内核操作调度器对线程进行调度，内核负责将线程的任务映射到处理器上
    * 每个KLT可视为内核的分身
    * 多线程内核：支持多线层的内核
    * 轻量级进程LWP: KLT的高级接口；也是通常意义上说的线程；每个LWP都有一个KLT支持
    * 一对一的线程模型：因为LWP和KLT之间为一对一的关系，这种线程模型称为一对一线程模型
    * LWP的限制：
      * 各种线程操作需要进行系统调用；而系统调用需要在用户态和内核态进行切换
      * LWP消耗内核资源，能支持的LWP数量有限
  * 使用用户线程实现
    * 广义：不是KLT就是用户线程UT，包括LWP
    * 狭义：完全建立在用户空间上的线程库上，系统内核不能感知其存在的线程
    * 一对多的线程模型：用户线程低消耗可以支持大量用户线程，形成进程和线程1：N的关系，也称一对多的线程模型
    * 使用困难：操作系统只把处理器资源分配到进程，很难处理诸如“阻塞如何处理，处理器映射”等问题
  * 使用用户线程+轻量级进程实现
    * 多对多的线程模型：混合使用两种线程，比例不定，为多对多的线程模型
* Java线程的实现
  * 基于操作系统原生线程模型来实现
  * 操作系统支持什么样的线程模型决定Java虚拟机的线程怎样映射
  * 线程模型影响：对线程的并发规模&操作成本会造成影响

---

##### 3.3.2. Java线程调度

* 线程调度：系统为线程分配处理器的过程
* 主要调度方式：
  * 协同式线程调度
    * 线程自己决定自己的执行时间
    * 线程工作执行完后，主动通知系统切换到其他线程
    * 好处：没有线程同步问题
    * 坏处：对系统来说执行时间不可控，可能阻塞
  * 抢占式线程调度
    * 由系统为每个线程分配执行时间
    * 系统可以强制切换线程
    * 系统可以控制线程执行时间
    * 无阻塞问题
    * 是Java使用的线程调度方式

---

##### 3.3.3. 线程状态转换

* New: 创建未启动
* Runnable：包括Running & Ready;可能正在执行；可能正在等到CPU分配执行时间片
* Waiting：不会被CPU分配执行时间片，等待被其他线程显示唤醒
  * Object.wait()
  * Thread.join()
  * LockSupport.park()
* Timed Waiting: 不会被CPU分配执行时间片，无需显示唤醒，一定时间后自动醒来
  * Thread.sleep()
  * 设置了 Timeout参数的Object.wait() / Thread.join()
  * LockSupport.parkUntil()/parkNanos()
* Blocked: 线程被阻塞，等待获取一个排他锁
* Terminated：已经终止的线程的状态

---

### 4. 常见面试题

* 

### 5. 综述

* 

### 6. 参考资料

* 《深入Java虚拟机-JVM高级特性与最佳实践》